--- a/target/linux/ipq40xx/files/drivers/net/dsa/qca/qca8k-ipq4019.c
+++ b/target/linux/ipq40xx/files/drivers/net/dsa/qca/qca8k-ipq4019.c
@@ -68,186 +71,38 @@ static const struct qca8k_mib_desc ar8327_mib[] = {
 	MIB_DESC(1, 0x9c, "TxExcDefer"),
 	MIB_DESC(1, 0xa0, "TxDefer"),
 	MIB_DESC(1, 0xa4, "TxLateCol"),
+	MIB_DESC(1, 0xa8, "RXUnicast"),
+	MIB_DESC(1, 0xac, "TXunicast"),
 };
 
-/* The 32bit switch registers are accessed indirectly. To achieve this we need
- * to set the page of the register. Track the last page that was set to reduce
- * mdio writes
- */
-static u16 qca8k_current_page = 0xffff;
-
-static void
-qca8k_split_addr(u32 regaddr, u16 *r1, u16 *r2, u16 *page)
-{
-	regaddr >>= 1;
-	*r1 = regaddr & 0x1e;
-
-	regaddr >>= 5;
-	*r2 = regaddr & 0x7;
-
-	regaddr >>= 3;
-	*page = regaddr & 0x3ff;
-}
-
-static int
-qca8k_mii_read32(struct mii_bus *bus, int phy_id, u32 regnum, u32 *val)
-{
-	int ret;
-
-	ret = bus->read(bus, phy_id, regnum);
-	if (ret >= 0) {
-		*val = ret;
-		ret = bus->read(bus, phy_id, regnum + 1);
-		*val |= ret << 16;
-	}
-
-	if (ret < 0) {
-		dev_err_ratelimited(&bus->dev,
-				    "failed to read qca8k 32bit register\n");
-		*val = 0;
-		return ret;
-	}
-
-	return 0;
-}
-
-static void
-qca8k_mii_write32(struct mii_bus *bus, int phy_id, u32 regnum, u32 val)
-{
-	u16 lo, hi;
-	int ret;
-
-	lo = val & 0xffff;
-	hi = (u16)(val >> 16);
-
-	ret = bus->write(bus, phy_id, regnum, lo);
-	if (ret >= 0)
-		ret = bus->write(bus, phy_id, regnum + 1, hi);
-	if (ret < 0)
-		dev_err_ratelimited(&bus->dev,
-				    "failed to write qca8k 32bit register\n");
-}
-
-static int
-qca8k_set_page(struct mii_bus *bus, u16 page)
-{
-	int ret;
-
-	if (page == qca8k_current_page)
-		return 0;
-
-	ret = bus->write(bus, 0x18, 0, page);
-	if (ret < 0) {
-		dev_err_ratelimited(&bus->dev,
-				    "failed to set qca8k page\n");
-		return ret;
-	}
-
-	qca8k_current_page = page;
-	usleep_range(1000, 2000);
-	return 0;
-}
-
 static int
 qca8k_read(struct qca8k_priv *priv, u32 reg, u32 *val)
 {
-	struct mii_bus *bus = priv->bus;
-	u16 r1, r2, page;
-	int ret;
-
-	qca8k_split_addr(reg, &r1, &r2, &page);
-
-	mutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);
-
-	ret = qca8k_set_page(bus, page);
-	if (ret < 0)
-		goto exit;
-
-	ret = qca8k_mii_read32(bus, 0x10 | r2, r1, val);
-
-exit:
-	mutex_unlock(&bus->mdio_lock);
-	return ret;
+	return regmap_read(priv->regmap, reg, val);
 }
 
 static int
 qca8k_write(struct qca8k_priv *priv, u32 reg, u32 val)
 {
-	struct mii_bus *bus = priv->bus;
-	u16 r1, r2, page;
-	int ret;
-
-	qca8k_split_addr(reg, &r1, &r2, &page);
-
-	mutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);
-
-	ret = qca8k_set_page(bus, page);
-	if (ret < 0)
-		goto exit;
-
-	qca8k_mii_write32(bus, 0x10 | r2, r1, val);
-
-exit:
-	mutex_unlock(&bus->mdio_lock);
-	return ret;
+	return regmap_write(priv->regmap, reg, val);
 }
 
 static int
 qca8k_rmw(struct qca8k_priv *priv, u32 reg, u32 mask, u32 write_val)
 {
-	struct mii_bus *bus = priv->bus;
-	u16 r1, r2, page;
-	u32 val;
-	int ret;
-
-	qca8k_split_addr(reg, &r1, &r2, &page);
-
-	mutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);
-
-	ret = qca8k_set_page(bus, page);
-	if (ret < 0)
-		goto exit;
-
-	ret = qca8k_mii_read32(bus, 0x10 | r2, r1, &val);
-	if (ret < 0)
-		goto exit;
-
-	val &= ~mask;
-	val |= write_val;
-	qca8k_mii_write32(bus, 0x10 | r2, r1, val);
-
-exit:
-	mutex_unlock(&bus->mdio_lock);
-
-	return ret;
+	return regmap_update_bits(priv->regmap, reg, mask, write_val);
 }
 
 static int
 qca8k_reg_set(struct qca8k_priv *priv, u32 reg, u32 val)
 {
-	return qca8k_rmw(priv, reg, 0, val);
+	return regmap_set_bits(priv->regmap, reg, val);
 }
 
 static int
 qca8k_reg_clear(struct qca8k_priv *priv, u32 reg, u32 val)
 {
-	return qca8k_rmw(priv, reg, val, 0);
-}
-
-static int
-qca8k_regmap_read(void *ctx, uint32_t reg, uint32_t *val)
-{
-	struct qca8k_priv *priv = (struct qca8k_priv *)ctx;
-
-	return qca8k_read(priv, reg, val);
-}
-
-static int
-qca8k_regmap_write(void *ctx, uint32_t reg, uint32_t val)
-{
-	struct qca8k_priv *priv = (struct qca8k_priv *)ctx;
-
-	return qca8k_write(priv, reg, val);
+	return regmap_clear_bits(priv->regmap, reg, val);
 }
 
 static const struct regmap_range qca8k_readable_ranges[] = {
