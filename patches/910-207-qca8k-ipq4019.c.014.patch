--- a/target/linux/ipq40xx/files/drivers/net/dsa/qca/qca8k-ipq4019.c
+++ b/target/linux/ipq40xx/files/drivers/net/dsa/qca/qca8k-ipq4019.c
@@ -2019,172 +1291,127 @@ static const struct dsa_switch_ops qca8k_switch_ops = {
 	.phylink_mac_config	= qca8k_phylink_mac_config,
 	.phylink_mac_link_down	= qca8k_phylink_mac_link_down,
 	.phylink_mac_link_up	= qca8k_phylink_mac_link_up,
-	.get_phy_flags		= qca8k_get_phy_flags,
 };
 
-static int qca8k_read_switch_id(struct qca8k_priv *priv)
-{
-	const struct qca8k_match_data *data;
-	u32 val;
-	u8 id;
-	int ret;
-
-	/* get the switches ID from the compatible */
-	data = of_device_get_match_data(priv->dev);
-	if (!data)
-		return -ENODEV;
-
-	ret = qca8k_read(priv, QCA8K_REG_MASK_CTRL, &val);
-	if (ret < 0)
-		return -ENODEV;
-
-	id = QCA8K_MASK_CTRL_DEVICE_ID(val & QCA8K_MASK_CTRL_DEVICE_ID_MASK);
-	if (id != data->id) {
-		dev_err(priv->dev, "Switch id detected %x but expected %x", id, data->id);
-		return -ENODEV;
-	}
-
-	priv->switch_id = id;
-
-	/* Save revision to communicate to the internal PHY driver */
-	priv->switch_revision = (val & QCA8K_MASK_CTRL_REV_ID_MASK);
-
-	return 0;
-}
-
 static int
-qca8k_sw_probe(struct mdio_device *mdiodev)
+qca8k_ipq4019_probe(struct platform_device *pdev)
 {
 	struct qca8k_priv *priv;
+	void __iomem *base, *psgmii;
+	struct device_node *np = pdev->dev.of_node, *mdio_np, *psgmii_ethphy_np;
 	int ret;
 
-	/* allocate the private data struct so that we can probe the switches
-	 * ID register
-	 */
-	priv = devm_kzalloc(&mdiodev->dev, sizeof(*priv), GFP_KERNEL);
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
-	priv->bus = mdiodev->bus;
-	priv->dev = &mdiodev->dev;
+	priv->dev = &pdev->dev;
 
-	priv->reset_gpio = devm_gpiod_get_optional(priv->dev, "reset",
-						   GPIOD_ASIS);
-	if (IS_ERR(priv->reset_gpio))
-		return PTR_ERR(priv->reset_gpio);
+	base = devm_platform_ioremap_resource_byname(pdev, "base");
+	if (IS_ERR(base))
+		return PTR_ERR(base);
 
-	if (priv->reset_gpio) {
-		gpiod_set_value_cansleep(priv->reset_gpio, 1);
-		/* The active low duration must be greater than 10 ms
-		 * and checkpatch.pl wants 20 ms.
-		 */
-		msleep(20);
-		gpiod_set_value_cansleep(priv->reset_gpio, 0);
+	priv->regmap = devm_regmap_init_mmio(priv->dev, base,
+					     &qca8k_ipq4019_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		ret = PTR_ERR(priv->regmap);
+		dev_err(priv->dev, "base regmap initialization failed, %d\n", ret);
+		return ret;
 	}
 
-	/* Check the detected switch id */
-	ret = qca8k_read_switch_id(priv);
-	if (ret)
+	psgmii = devm_platform_ioremap_resource_byname(pdev, "psgmii_phy");
+	if (IS_ERR(psgmii))
+		return PTR_ERR(psgmii);
+
+	priv->psgmii = devm_regmap_init_mmio(priv->dev, psgmii,
+					     &qca8k_ipq4019_psgmii_phy_regmap_config);
+	if (IS_ERR(priv->psgmii)) {
+		ret = PTR_ERR(priv->psgmii);
+		dev_err(priv->dev, "PSGMII regmap initialization failed, %d\n", ret);
 		return ret;
+	}
+
+	mdio_np = of_parse_phandle(np, "mdio", 0);
+	if (!mdio_np) {
+		dev_err(&pdev->dev, "unable to get MDIO bus phandle\n");
+		of_node_put(mdio_np);
+		return -EINVAL;
+	}
+
+	priv->bus = of_mdio_find_bus(mdio_np);
+	of_node_put(mdio_np);
+	if (!priv->bus) {
+		dev_err(&pdev->dev, "unable to find MDIO bus\n");
+		return -EPROBE_DEFER;
+	}
 
-	priv->ds = devm_kzalloc(&mdiodev->dev, sizeof(*priv->ds), GFP_KERNEL);
+	psgmii_ethphy_np = of_parse_phandle(np, "psgmii-ethphy", 0);
+	if (!psgmii_ethphy_np) {
+		dev_dbg(&pdev->dev, "unable to get PSGMII eth PHY phandle\n");
+		of_node_put(psgmii_ethphy_np);
+	}
+
+	if (psgmii_ethphy_np) {
+		priv->psgmii_ethphy = of_phy_find_device(psgmii_ethphy_np);
+		of_node_put(psgmii_ethphy_np);
+		if (!priv->psgmii_ethphy) {
+			dev_err(&pdev->dev, "unable to get PSGMII eth PHY\n");
+			return -ENODEV;
+		}
+	}
+
+	priv->ds = devm_kzalloc(priv->dev, sizeof(*priv->ds), GFP_KERNEL);
 	if (!priv->ds)
 		return -ENOMEM;
 
-	priv->ds->dev = &mdiodev->dev;
+	priv->ds->dev = priv->dev;
 	priv->ds->num_ports = QCA8K_NUM_PORTS;
-	priv->ds->configure_vlan_while_not_filtering = true;
 	priv->ds->priv = priv;
 	priv->ops = qca8k_switch_ops;
 	priv->ds->ops = &priv->ops;
+
 	mutex_init(&priv->reg_mutex);
-	dev_set_drvdata(&mdiodev->dev, priv);
+	platform_set_drvdata(pdev, priv);
 
 	return dsa_register_switch(priv->ds);
 }
 
-static void
-qca8k_sw_remove(struct mdio_device *mdiodev)
+static int
+qca8k_ipq4019_remove(struct platform_device *pdev)
 {
-	struct qca8k_priv *priv = dev_get_drvdata(&mdiodev->dev);
+	struct qca8k_priv *priv = dev_get_drvdata(&pdev->dev);
 	int i;
 
+	if (!priv)
+		return 0;
+
 	for (i = 0; i < QCA8K_NUM_PORTS; i++)
 		qca8k_port_set_status(priv, i, 0);
 
 	dsa_unregister_switch(priv->ds);
-}
-
-#ifdef CONFIG_PM_SLEEP
-static void
-qca8k_set_pm(struct qca8k_priv *priv, int enable)
-{
-	int i;
-
-	for (i = 0; i < QCA8K_NUM_PORTS; i++) {
-		if (!priv->port_sts[i].enabled)
-			continue;
-
-		qca8k_port_set_status(priv, i, enable);
-	}
-}
 
-static int qca8k_suspend(struct device *dev)
-{
-	struct qca8k_priv *priv = dev_get_drvdata(dev);
-
-	qca8k_set_pm(priv, 0);
-
-	return dsa_switch_suspend(priv->ds);
-}
+	dev_set_drvdata(&pdev->dev, NULL);
 
-static int qca8k_resume(struct device *dev)
-{
-	struct qca8k_priv *priv = dev_get_drvdata(dev);
-
-	qca8k_set_pm(priv, 1);
-
-	return dsa_switch_resume(priv->ds);
+	return 0;
 }
-#endif /* CONFIG_PM_SLEEP */
-
-static SIMPLE_DEV_PM_OPS(qca8k_pm_ops,
-			 qca8k_suspend, qca8k_resume);
-
-static const struct qca8k_match_data qca8327 = {
-	.id = QCA8K_ID_QCA8327,
-	.reduced_package = true,
-};
-
-static const struct qca8k_match_data qca8328 = {
-	.id = QCA8K_ID_QCA8327,
-};
-
-static const struct qca8k_match_data qca833x = {
-	.id = QCA8K_ID_QCA8337,
-};
 
-static const struct of_device_id qca8k_of_match[] = {
-	{ .compatible = "qca,qca8327", .data = &qca8327 },
-	{ .compatible = "qca,qca8328", .data = &qca8328 },
-	{ .compatible = "qca,qca8334", .data = &qca833x },
-	{ .compatible = "qca,qca8337", .data = &qca833x },
+static const struct of_device_id qca8k_ipq4019_of_match[] = {
+	{ .compatible = "qca,ipq4019-qca8337n" },
 	{ /* sentinel */ },
 };
 
-static struct mdio_driver qca8kmdio_driver = {
-	.probe  = qca8k_sw_probe,
-	.remove = qca8k_sw_remove,
-	.mdiodrv.driver = {
-		.name = "qca8k",
-		.of_match_table = qca8k_of_match,
-		.pm = &qca8k_pm_ops,
+static struct platform_driver qca8k_ipq4019_driver = {
+	.probe = qca8k_ipq4019_probe,
+	.remove = qca8k_ipq4019_remove,
+	.driver = {
+		.name = "qca8k-ipq4019",
+		.of_match_table = qca8k_ipq4019_of_match,
 	},
 };
 
-mdio_module_driver(qca8kmdio_driver);
+module_platform_driver(qca8k_ipq4019_driver);
 
 MODULE_AUTHOR("Mathieu Olivari, John Crispin <john@phrozen.org>");
-MODULE_DESCRIPTION("Driver for QCA8K ethernet switch family");
+MODULE_AUTHOR("Gabor Juhos <j4g8y7@gmail.com>, Robert Marko <robert.marko@sartura.hr>");
+MODULE_DESCRIPTION("Qualcomm IPQ4019 built-in switch driver");
 MODULE_LICENSE("GPL v2");
-MODULE_ALIAS("platform:qca8k");
diff --git a/target/linux/ipq40xx/files/drivers/net/dsa/qca/qca8k-ipq4019.h b/target/linux/ipq40xx/files/drivers/net/dsa/qca/qca8k-ipq4019.h
index e10571a398c98..a36eb0dadcb5e 100644
