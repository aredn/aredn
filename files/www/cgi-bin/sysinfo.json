#!/usr/bin/ucode
/*
 * Part of AREDN速 -- Used for creating Amateur Radio Emergency Data Networks
 * Copyright (C) 2025 Tim Wilkinson
 * Original Lua Copyright (C) 2016 Darryl Quinn
 * See Contributors file for additional contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Additional Terms:
 *
 * Additional use restrictions exist on the AREDN速 trademark and logo.
 * See AREDNLicense.txt for more info.
 *
 * Attributions to the AREDN速 Project must be retained in the source code.
 * If importing this code into a new or existing project attribution
 * to the AREDN速 project must be added to the source code.
 *
 * You must not misrepresent the origin of the material contained within.
 *
 * Modified versions must be modified to attribute to the original source
 * and be marked in reasonable ways as differentiate it from the original
 * version
 */

import * as fs from "fs";
import * as uci from "uci";
import * as rtnl from "rtnl";
import * as configuration from "aredn.configuration";
import * as hardware from "aredn.hardware";
import * as radios from "aredn.radios";

const c = uci.cursor();
const q = getenv("QUERY_STRING") || "";

function capture(cmd)
{
	const p = fs.popen(cmd);
	if (p) {
		const v = p.read("all");
		p.close();
		return trim(v);
	}
	return null;
}

function tonumber(v)
{
	if (v == "" || v == null) {
		return null;
	}
	return 1 * v;
}

function strip(o)
{
	for (let k in o) {
		if (o[k] == null) {
			delete o[k];
		}
	}
	return o;
}

const info = strip({
	api_version: "2.0",
	node: configuration.getName(),
	node_details: strip({
		model: capture("/usr/local/bin/get_model"),
		description: configuration.getSettingAsString("description_node"),
		board_id: hardware.getBoardId(),
		firmware_mfg: "AREDN",
		firmware_version: configuration.getFirmwareVersion(),
		mesh_gateway: c.get("aredn", "@wan[0]", "mesh_to_local_wan") == "1",
		mesh_supernode: c.get("aredn", "@supernode[0]", "enable") == "1"
	}),
	tunnels: {
		active_tunnel_count: tonumber(capture("wg | grep interface | wc -l"))
	},
	lat: tonumber(c.get("aredn", "@location[0]", "lat")),
    lon: tonumber(c.get("aredn", "@location[0]", "lon")),
    gridsquare: c.get("aredn", "@location[0]", "gridsquare")
});

// Mesh RF info
info.meshrf = (function(){
	const config = radios.getConfiguration();
	for (let i = 0; i < length(config); i++) {
		const cfg = config[i];
		const mode = cfg.mode;
		switch (mode.mode) {
			case radios.RADIO_MESH:
			case radios.RADIO_MESHPTP:
			case radios.RADIO_MESHPTMP:
			case radios.RADIO_MESHSTA:
				return strip({
					status: "on",
					mode: (mode.mode === radios.RADIO_MESH ? "adhoc" : mode.mode === radios.RADIO_MESHSTA ? "sta" : "ap"),
					ssid: mode.ssid,
					channel: mode.channel,
					chanbw: mode.bandwidth,
					freq: hardware.getChannelFrequency(config[i].iface, mode.channel),
					azimuth: tonumber(c.get("aredn", "@location[0]", "azimuth")),
					elevation: tonumber(c.get("aredn", "@location[0]", "elevation")),
					height: tonumber(c.get("aredn", "@location[0]", "height")),
					antenna: cfg.ant,
					antenna_aux: cfg.antsaux
				});
			default:
				break;
		}
	}
	return { status: "off" };
})();

// UPTIME AND LOADAVGS
info.sysinfo = (function(){
	const d = split(fs.readfile("/proc/uptime"), " ");
    const up = int(d[0]);
    let uptime = sprintf("%d:%02d", int(up / 3600) % 24, int(up / 60) % 60);
    if (up >= 172800) {
        uptime = int(up / 86400) + " days, " + uptime;
    }
    else if (up > 86400) {
        uptime = "1 day, " + uptime;
    }
    const ld = split(fs.readfile("/proc/loadavg"), " ");
	return {
		uptime: uptime,
		loads: [ 1 * ld[0], 1 * ld[1], 1 * ld[2] ]
	};
})();

// INTERFACES
info.interfaces = (function(){
	const interfaces = [];
	const ifs = rtnl.request(rtnl.const.RTM_GETLINK, rtnl.const.NLM_F_DUMP, {});
	for (let i = 0; i < length(ifs); i++) {
        const iface = ifs[i];
		if (iface.dev === "lo" || iface.dev === "wlan0-1" || iface.dev === "wlan1-1" || iface.dev === "tunl0") {
			continue;
		}
		const ip = capture(`ip addr show dev ${iface.dev} | grep inet\\  | sed -e 's/.*inet //' -e 's/\\/.*//'`);
		const ii = { name: iface.dev };
		if (iface.address) {
			ii.mac = iface.address;
		}
		if (ip) {
			ii.ip = ip;
		}
		push(interfaces, ii);
	}
	return interfaces;
})();

// LINKS
if (match(q, /link_info=1/)) {
	info.link_info = {};
	if (fs.access("/tmp/lqm.info")) {
		const lqm = json(fs.readfile("/tmp/lqm.info", "r"));
		for (let mac in lqm.trackers) {
			const tracker = lqm.trackers[mac];
			const ip = tracker.canonical_ip || tracker.ip;
			if (ip && tracker.hostname) {
				info.link_info[ip] = {
					linkType: uc(tracker.type),
					hostname: tracker.hostname,
					interface: tracker.device
				};
			}
		}
	}
}

// HOSTS
if (match(q, /hosts=1/)) {
	info.hosts = (function(){
		const hosts = [];
		const d = fs.opendir("/var/run/arednlink/hosts");
		if (d) {
			for (let name = d.read(); name; name = d.read()) {
				if (name == "." || name == "..") {
					continue;
				}
				const f = fs.open(`/var/run/arednlink/hosts/${name}`);
				if (f) {
					for (let line = f.read("line"); length(line); line = f.read("line")) {
						const m = match(trim(line), /^([0-9\.]+)[ \t]+([^ \.]+)$/);
						if (m) {
							push(hosts, { ip: m[1], name: m[2] });
						}
					}
					f.close();
				}
			}
			d.close();
		}
		return hosts;
	})();
}

// SERVICES
if (match(q, /services=1/)) {
	info.services = (function(){
		const services = [];
		const d = fs.opendir("/var/run/arednlink/services");
		if (d) {
			for (let name = d.read(); name; name = d.read()) {
				if (name == "." || name == "..") {
					continue;
				}
				const f = fs.open(`/var/run/arednlink/services/${name}`);
				if (f) {
					for (let line = f.read("line"); length(line); line = f.read("line")) {
						const m = match(trim(line), /^([^|]*)\|([^|]*)\|(.*)$/);						
						if (m) {
							push(services, {
								name: m[3],
								protocol: m[2],
								ip: name,
								link: match(m[1], /:0\//) ? "" : m[1]
							});
						}
					}
					f.close();
				}
			}
			d.close();
		}
		return services;
	})();
}

// LOCALLY HOSTED SERVICES ONLY
if (match(q, /services_local=1/)) {
	info.services_local = (function(){
		const services = [];
		const f = fs.open(`/etc/arednlink/services`);
		if (f) {
			for (let line = f.read("line"); length(line); line = f.read("line")) {
				const m = match(trim(line), /^([^|]*)\|([^|]*)\|(.*)$/);						
				if (m) {
					push(services, {
						name: m[3],
						protocol: m[2],
						link: match(m[1], /:0\//) ? "" : m[1]
					});
				}
			}
			f.close();
		}
		return services;
	})();
}

// LQM INFO
if (match(q, /lqm=1/)) {
	info.lqm = {
		enabled: true,
		config: {
			user_blocks: c.get("aredn", "@lqm[0]", "user_blocks") || ""
		},
		info: json(fs.readfile("/tmp/lqm.info"))
	};
}

// Output the HTTP header for JSON
print("Content-type: application/json\r\n");
print("Cache-Control: no-store\r\n");
print("Access-Control-Allow-Origin: *\r\n");
print("\n");

// Output the info table as json
printf("%.2J\n", info);
