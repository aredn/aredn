#!/usr/bin/ucode
/*
 * Part of AREDN速 -- Used for creating Amateur Radio Emergency Data Networks
 * Copyright (C) 2022-2025 Tim Wilkinson
 * See Contributors file for additional contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Additional Terms:
 *
 * Additional use restrictions exist on the AREDN速 trademark and logo.
 * See AREDNLicense.txt for more info.
 *
 * Attributions to the AREDN速 Project must be retained in the source code.
 * If importing this code into a new or existing project attribution
 * to the AREDN速 project must be added to the source code.
 *
 * You must not misrepresent the origin of the material contained within.
 *
 * Modified versions must be modified to attribute to the original source
 * and be marked in reasonable ways as differentiate it from the original
 * version
 */

import * as fs from "fs";
import * as uci from "uci";
import * as configuration from "aredn.configuration";
import * as network from "aredn.network";

const node = configuration.getName();

const q = getenv("QUERY_STRING") || "";
let m = match(q, /server=([^&]*)/);
let server = m && m[1];
m = match(q, /protocol=([^&]*)/);
const protocol = (m && m[1]) || "tcp";
const kill = match(q, /kill=1/) ? true : false;

print("Content-type: text/html\r\n");
print("Cache-Control: no-store\r\n");
print("Access-Control-Allow-Origin: *\r\n");
print("\r\n");
if (uci.cursor().get("aredn", "@iperf[0]", "enable") == "0") {
    print("<html><head><title>CLIENT DISABLED</title></head><body><pre>iperf is disabled</pre></body></html>\n");
}
else if (server == null) {
    print("<html><head><title>ERROR</title></head><body><pre>Provide a server name to run a test between this client and a server [/cgi-bin/iperf?server=&lt;ServerName&gt;&amp;protocol=&lt;udp|tcp&gt;]</pre></body></html>\n");
}
else if (match(server, /[^0-9a-zA-Z\.\-]/)) {
    print("<html><head><title>ERROR</title></head><body><pre>Illegal server name</pre></body></html>\n");
}
else {
    if (server == "") {
        // iperf server
        if (kill) {
            system("/usr/bin/killall -9 iperf3 > /dev/null 2>&1");
        }
        else {
            const p = fs.popen("/bin/pidof iperf3");
            if (p) {
                if (p.read("all") != "") {
                    print("<html><head><title>BUSY</title></head><body><pre>iperf server busy</pre></body></html>\n");
                    p.close();
                    return;
                }
                p.close();
            }
        }
        const running = fs.popen(`/usr/bin/iperf3 -s -1 --idle-timeout 20 --forceflush -B 0.0.0.0`);
        if (!running) {
            print("<html><head><title>SERVER ERROR</title></head><body><pre>iperf server failed to start</pre></body></html>\n");
            return;
        }
        running.read("line");
        print("<html><head><title>RUNNING</title></head><body><pre>iperf server running</pre></body></html>\n");
        flush();
        return;
    }
    else {
        // iperf client
        if (!match(server, /\./)) {
            server += ".local.mesh";
        }
        const ip = network.getIPAddressFromHostname(server);
        if (!ip) {
            print("<html><head><title>SERVER ERROR</title></head><body><pre>iperf no such server</pre></body></html>\n");
        }
        else {
            const remote = fs.popen(`/bin/uclient-fetch -q -O - 'http://${ip}:8080/cgi-bin/iperf?${kill ? "kill=1&" : ""}server=' 2>&1`);
            if (!remote) {
                print("<html><head><title>CLIENT ERROR</title></head><body><pre>iperf failed to call remote server</pre></body></html>\n");
                return;
            }
            for (;;) {
                const line = remote.read("line");
                if (length(line) === 0) {
                    print("<html><head><title>ERROR</title></head><body><pre>iperf unknown error</pre></body></html>\n");
                    break;
                }
                else if (match(line, /CLIENT DISABLED/)) {
                    print("<html><head><title>SERVER DISABLED</title></head><body><pre>iperf server is disabled</pre></body></html>\n");
                    break;
                }
                else if (match(line, /BUSY/)) {
                    print("<html><head><title>SERVER BUSY</title></head><body><pre>iperf server is busy</pre></body></html>\n");
                    break;
                }
                else if (match(line, /ERROR/)) {
                    print("<html><head><title>SERVER ERROR</title></head><body><pre>iperf server error</pre></body></html>\n");
                    break;
                }
                else if (match(line, /RUNNING/)) {
                    const running = fs.popen(`/usr/bin/iperf3 --forceflush --rcv-timeout 20000 -b 0 -Z -c ${ip}${protocol == "udp" ? " -u" : ""} -l 16K 2>&1`);
                    if (!running) {
                        print("<html><head><title>CLIENT ERROR</title></head><body><pre>iperf client failed</pre></body></html>\n");
                        break;
                    }
                    print("<html><head><title>SUCCESS</title></head>");
                    print(`<body><pre>Client: ${node}\nServer: ${server}\n`);
                    flush();
                    for (let line = running.read("line"); length(line); line = running.read("line")) {
                        print(line);
                        flush();
                    }
                    running.close();
                    print("</pre></body></html>\n");
                    break;
                }
                break;
            }
            remote.close();
        }
    }
}
