#!/usr/bin/ucode
/*
 * Part of AREDN速 -- Used for creating Amateur Radio Emergency Data Networks
 * Copyright (C) 2024,2025 Tim Wilkinson
 * See Contributors file for additional contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Additional Terms:
 *
 * Additional use restrictions exist on the AREDN速 trademark and logo.
 * See AREDNLicense.txt for more info.
 *
 * Attributions to the AREDN速 Project must be retained in the source code.
 * If importing this code into a new or existing project attribution
 * to the AREDN速 project must be added to the source code.
 *
 * You must not misrepresent the origin of the material contained within.
 *
 * Modified versions must be modified to attribute to the original source
 * and be marked in reasonable ways as differentiate it from the original
 * version
 */

import * as fs from "fs";
import * as uci from "uci";
import * as hardware from "aredn.hardware";
import * as network from "aredn.network";

// Helpers

function isNull(v)
{
    if (!v || v == "" || v == 0 || v == "0") {
        return true;
    }
    else {
        return false;
    }
}

function isNotNull(v)
{
    return !isNull(v);
}

function hex2str(hexstr)
{
    let s = "";
    if (hex) {
        for (let i = 0; i < length(hexstr); i += 2) {
            const p = substr(hexstr, i, 2);
            if (match(p, /[0-9a-f][0-9a-f]"/)) {
                s += chr(hex(p));
            }
            else {
                s += p;
            }
        }
    }
    return s;
}

function tonumber(v)
{
    if (v === "" || v === null) {
        return null;
    }
    return 1 * v;
}

function tablesize(t)
{
    return length(keys(t));
}

function getSubtable(container, key)
{
    let subtable = container[key];
    if (!subtable) {
        subtable = {};
        container[key] = subtable;
    }
    return subtable;
}

function getBoardNetworkIfName(type)
{
    const board = hardware.getBoard();
    const network = board.network && board.network[type];
    if (network) {
        if (network.ifname) {
            return network.ifname;
        }
        if (network.device) {
            return network.device;
        }
        if (network.ports) {
            return join(" ", network.ports);
        }
    }
    return "";
}

function removeAll(dir)
{
    system(`/bin/rm -rf ${dir}`);
}

// Helper end

const FORCED = "force";
const UNFORCED = "onrequest";
const OPT_RAPID_COMMIT = "80";
const OPT_VENDOR_ID_ENCAP = "125";
const VI_ENCAP = "vi-encap:";

const c = uci.cursor();
const cm = uci.cursor("/etc/config.mesh");
const nvram = uci.cursor("/etc/local/uci");

const ieee80211 = "/sys/class/ieee80211/";

const node = nvram.get("hsmmmesh", "settings", "node");
const tactical = nvram.get("hsmmmesh", "settings", "tactical");
const mac2 = nvram.get("hsmmmesh", "settings", "mac2");
const dtdmac = nvram.get("hsmmmesh", "settings", "dtdmac");

const is_supernode = cm.get("aredn", "@supernode[0]", "enable") == "1";
const wifi_mon_enable = false;
const deleteme = {};
const cfg = {
    description_node: "",
    lan_intf: getBoardNetworkIfName("lan"),
    wan_intf: getBoardNetworkIfName("wan"),
    bridge_network_config: "",
    lan_network_config: "",
    wan_network_config: "",
    dtdlink_network_config: "",
    wifi_network_config: "",
    wireguard_network_config: "",
    dtdlink_interfaces: "\tlist network 'dtdlink'",
    vpn_interfaces: "",
    tun_devices_config: "",
    ntp_enabled: "0"
};

// Track the changes so we can make better decissions about what to restart/reboot
const changes = {}

function validConfig(config) {
    removeAll("/tmp/uci_validate");
    fs.mkdir("/tmp/uci_validate");
    fs.writefile("/tmp/uci_validate/config", config);
    const r = system("/sbin/uci -c /tmp/uci_validate import dummy < /tmp/uci_validate/config") == 0;
    removeAll("/tmp/uci_validate");
    return r;
}

function isNatMode()
{
    return isNull(cfg.dmz_mode);
}

function isDmzMode()
{
    return isNotNull(cfg.dmz_mode) && cfg.dmz_mode != "1";
}

function isAltNetMode()
{
    return cfg.dmz_mode == "1";
}

function expandVars(contents)
{
    const lines = split(contents, "\n");
    const nlines = [];
    for (let i = 0; i < length(lines); i++) {
        let line = trim(lines[i]);
        const m = match(line, /^include[ \t]+([^ \t]+)$/);
        if (m) {
            if (fs.access(m[1])) {
                line = expandVars(fs.readfile(m[1]));
                if (!validConfig(line)) {
                    print(`Invalid config fragment: ${m[1]}\n`);
                    exit(1);
                }
            }
            else {
                line = null;
            }
        }
        else if (!match(line, /^#/)) {
            const params = match(line, /<([^ \t]+)>/g);
            if (params) {
                for (let p = 0; p < length(params); p++) {
                    const parm = params[i][1];
                    if (deleteme[parm]) {
                        line = null;
                    }
                    else if (parm == "NODE") {
                        line = replace(line, "<NODE>", node);
                    }
                    else if (parm == "MAC2") {
                        line = replace(line, "<MAC2>", mac2);
                    }
                    else if (parm == "DTDMAC") {
                        line = replace(line, "<DTDMAC>", dtdmac);
                    }
                    else if (cfg[parm]) {
                        line = replace(line, `<${parm}>`, cfg[parm]);
                    }
                    else {
                        line = null;
                    }
                }
            }
        }
        if (line != null) {
            push(nlines, line);
        }
    }
    return join("\n", nlines);
}

// Load the configuration
const cms = cm.get_all("setup", "globals") || {};
for (let k in cms) {
    if (match(k, /^\./)) {
        cfg[k] = cms[k];
    }
}

// Select the mesh configuration
const default_mesh_distance = 80550; // 50.1 miles
let mesh_wifi = "br-nomesh";
let mesh_ssid = "";
let mesh_channel = "";
let mesh_chanbw = "";
let mesh_txpower = null;
let mesh_distance = "";
if (cfg.radio0_mode == "mesh" || cfg.radio0_mode == "meshap" || cfg.radio0_mode == "meshptp" || cfg.radio0_mode == "meshsta") {
    mesh_wifi = "wlan0";
    mesh_channel = tonumber(cfg.radio0_channel);
    mesh_chanbw = tonumber(cfg.radio0_bandwidth);
    mesh_ssid = cfg.radio0_ssid;
    mesh_txpower = tonumber(cfg.radio0_txpower);
    mesh_distance = tonumber(cfg.radio0_distance || 0);
}
else if (cfg.radio1_mode == "mesh" || cfg.radio1_mode == "meshap" || cfg.radio1_mode == "meshptp" || cfg.radio1_mode == "meshsta") {
    mesh_wifi = "wlan1";
    mesh_channel = tonumber(cfg.radio1_channel);
    mesh_chanbw = tonumber(cfg.radio1_bandwidth);
    mesh_ssid = cfg.radio1_ssid;
    mesh_txpower = tonumber(cfg.radio1_txpower);
    mesh_distance = tonumber(cfg.radio1_distance || 0);
}
if (mesh_distance == 0) {
    mesh_distance = default_mesh_distance;
}

// Delete some config lines if necessary
if (cfg.wan_proto != "static") {
    deleteme.wan_ip = true;
    deleteme.wan_gw = true;
    deleteme.wan_mask = true;
}
if (isDmzMode() || isAltNetMode() || cfg.wan_proto != "disabled") {
    deleteme.lan_gw = true;
}

// lan_dhcp sense is inverted in the dhcp config file
// and it is a checkbox so it may not be defined - this fixes that
if (cfg.lan_dhcp == "1") {
    cfg.lan_dhcp = 0;
}
else {
    cfg.lan_dhcp = 1;
}

// handle possible remote syslog
const remote_log = cm.get("aredn", "@remotelog[0]", "url") || "";
const pip = match(remote_log, /^(.+):\/\/(\d+\.\d+\.\d+\.\d+):(\d+)$/);
if (pip && (pip[1] == "tcp" || pip[1] == "udp") && (pip[3] > 0 && pip[3] < 65536) && iptoarr(pip[2])) {
    cfg.remote_log_proto = pip[1];
    cfg.remote_log_ip = pip[2];
    cfg.remote_log_port = int(pip[3]);
}
else {
    deleteme.remote_log_proto = true;
    deleteme.remote_log_ip = true;
    deleteme.remote_log_port = true;
}

// Sensible dmz_mode default
if (isNull(cfg.dmz_mode)) {
    cfg.dmz_mode = "0";
}

// switch to dmz values if needed
if (isDmzMode()) {
    cfg.lan_ip = cfg.dmz_lan_ip;
    cfg.lan_mask = cfg.dmz_lan_mask;
    cfg.dhcp_start = cfg.dmz_dhcp_start;
    cfg.dhcp_end = cfg.dmz_dhcp_end;
}
cfg.dhcp_limit = cfg.dhcp_end - cfg.dhcp_start + 1;

// verify that we have all the variables we need
const dcm = fs.diropen("/etc/config.mesh");
if (dcm) {
    for (let file = dcm.read(); file; file = dcm.read()) {
        if (file === "." || file === "..") {
            continue;
        }
        const f = fs.open(`/etc/config.mesh/${file}`);
        if (f) {
            for (let line = f.read("line"); length(line); line = f.read("line")) {
                if (!match(line, /^#/)) {
                    const params = match(line, /<([^ \t]+)>/g);
                    if (params) {
                        for (let p = 0; p < length(params); p++) {
                            const parm = params[i][1];
                            if (uc(parm) == parm) {
                                // nvram variable
                                if (!nvram.get("hsmmmesh", "settings", parm)) {
                                    print(`WARNING: nv parameter '${parm}' in file '/etc/config.mesh/${file}' does not exist\n`);
                                }
                            }
                            else if (cfg[parm] && !deleteme[parm]) {
                                print(`WARNING: parameter '${parm}' in file '/etc/config.mesh/${file}' does not exist\n`);
                            }
                        }
                    }
                }
            }
            f.close();
        }
    }
    dcm.close();
}

// generate the bridge configuration
if (fs.access("/etc/aredn_include/bridge.network.user")) {
    cfg.bridge_network_config = expandVars(fs.readfile("/etc/aredn_include/bridge.network.user"));
    if (!validConfig(cfg.bridge_network_config)) {
        print("Invalid config fragment: /etc/aredn_include/bridge.network.user\n");
        exit(1);
    }
}
else {
    const list = {};
    const networks = [ "lan", "wan", "dtdlink" ];
    for (let i = 0; i < length(networks); i++) {
        const ports = split(getBoardNetworkIfName(networks[i]), " ");
        for (let p = 0; p < length(ports); p++) {
            list[replace(ports[p], /\..*$/, "")] = true;
        }
    }
    let config = "config device\n\toption name 'br0'\n\toption type 'bridge'\n\toption vlan_filtering '1'\n";
    for (let port in ports) {
        config += `\tlist ports '${port}'\n`;
    }
    cfg.bridge_network_config = config;
}

// generate the network configurations
const wan_wifi_enabled = (cfg.radio0_mode == "wan" || cfg.radio1_mode == "wan");
const cnetworks = [ "lan", "wan", "dtdlink", ,"wifi" ];
for (let i = 0; i < length(cnetworks); i++) {
    const net = cnetworks[i];
    let wireless = false;
    let config = "";
    // User override
    // Ignore wan override if wan wifi is enabled
    if (fs.access(`/etc/aredn_include/${net}.network.user`) && !(net == wan && wan_wifi_enabled)) {
        const f = fs.open(`/etc/aredn_include/fixedmac.${net}`);
        if (f) {
            for (let line = f.read("line"); length(line); line = f.read("line")) {
                const m = match(line, /option[ \t]]+macaddr[ \t]]+([^ \t]+)/);
                if (m) {
                    cfg[`${net}_mac`] = m[1];
                }
            }
            f.close();
        }
        config = expandVars(fs.readfile(`/etc/aredn_include/${net}.network.user`));
        if (!validConfig(config)) {
            print("Invalid config fragment: /etc/aredn_include/${net}.network.user\n");
            exit(1);
        }
    }
    else {
        // generate a complete config
        let vlan = null;
        let ports = split(getBoardNetworkIfName(net), " ");

        if (net == "lan") {
            // If the LAN has be given a vlan to use (usually by a switch) we use that here,
            // otherwise we just use '3'
            const lvlan = match(ports[0], /\.(\d+)$/);
            if (lvlan) {
                vlan = `${lvlan[1]}:t`;
            }
            else {
                vlan = "3:u";
            }
        }
        else if (net == "wan") {
            // wifi can be used for the WAN (we become a wifi client)
            if (cfg.radio0_mode == "wan") {
                wireless = true;
                ports = [ "wlan0" ];
            }
            else if (cfg.radio1_mode == "wan") {
                wireless = true;
                ports = [ "wlan1" ];
            }
            else {
                // If the WAN has been given a vlan to use (usually 1) we use that here.
                const wvlan = match(ports[0], /\.(\d+)$/);
                if (wvlan) {
                    vlan = `${wvlan[1]}:t`;
                }
                else {
                    vlan = "4:u";
                }
                // handle wan vlan override
                const m = match(cm.get("setup", "globals", "wan_intf") || "", /([a-zA-Z0-9]+\.)(\d+)/);
                if (m) {
                    vlan = `${m[2]}:t`;
                    ports = [ `${m[1]}${m[2]}` ];
                }
            }
        }
        else if (net == "dtdlink") {
            // Always vlan 2
            vlan = "2:t";
            cfg.dtdlink_proto = "static";
            cfg.dtdlink_mask = "255.0.0.0";
        }
        else if (net == "wifi") {
            wireless = true;
            cfg.wifi_proto = "static";
            ports = [ mesh_wifi ];
        }

        if (vlan) {
            // Vlan configuration
            const m = match(vlan, /(.*):(.*)/);
            config += `\nconfig bridge-vlan\n\toption device 'br0'\n\toption vlan '${m[1]}'\n`;
            for (let p = 0; p < length(ports); p++) {
                config += `\tlist ports '${replace(ports[p], /\..*$/, "")}:${m[2]}'\n"`;
            }
            config += "\n";
            ports = [ `br0.${m[1]}` ];
        }

        let proto = cfg[`${net}_proto`] || "";
        let ipaddr = deleteme[`${net}_ip`] ? "" : (cfg[`${net}_ip`] || "");
        let netmask = deleteme[`${net}_mask`] ? "" : (cfg[`${net}_mask`] || "");
        let mtu = cfg[`${net}_mtu`] || "";
        let dns1 = "";
        let dns2 = "";
        if (net == "lan") {
            dns1 = cfg.wan_dns1 || "";
            dns2 = cfg.wan_dns2 || "";
        }
        let gateway = deleteme[`${net}_gw`] ? "" : (cfg[`${net}_gw`] || "");
        if (!wireless) {
            config += `\toption name 'br-${net}'\n\toption type 'bridge'\n`;
        }
        else {
            netmask = "255.255.255.255";
        }
        if (fs.access(`/etc/aredn_include/fixedmac.${net}`)) {
            config += fs.readfile(`/etc/aredn_include/fixedmac.${net}`);
        }

        if (!wireless) {
            if (length(ports) == 0) {
                config += "\toption bridge_empty '1'\n";
            }
            else {
                for (let p = 0; p < length(ports); p++) {
                    config += `\tlist ports '${ports[p]}'\n`;
                }
            }
        }
        else {
            config += `\toption name '${ports[0]}'\n`;
            if (!match(ports[0], "^wlan")) {
                config += "\toption type 'bridge'\n\toption bridge_empty '1'\n";
            }
        }

        config += `\nconfig interface ${net}\n`;
        if (wireless) {
            config += `\toption device '${ports[0]}'\n`;
        }
        else {
            config += `\toption device 'br-${net}'\n`;
        }
        if (proto != "") {
            config += `\toption proto '${proto}'\n`;
        }
        if (mtu != "") {
            config += `\toption mtu '${mtu}'\n`;
        }
        if (ipaddr != "") {
            config += `\toption ipaddr '${ipaddr}'\n`;
        }
        if (netmask != "") {
            config += `\toption netmask '${netmask}'\n`;
        }
        if (dns1 != "" || dns2 != "") {
            config += `\toption dns '${dns1 || ""}${dns1 && dns2 ? " " : ""}${dns2 || ""}'\n`;
        }
        if (gateway != "") {
            config += `\toption gateway '${gateway}'\n`;
        }
    }
    cfg[`${net}_network_config`] = config;
}

// Generate the tunnel configurations
let tun_start = cm.get("wireguard", "@network[0]", "start");
if (is_supernode && tun_start && match(tun_start, /^172\.31\./)) {
    tun_start = `172.30.${substr(tun_start, 8)}`;
    cm.set("wireguard", "@network[0]", "start", tun_start);
    cm.commit("wireguard");
}
const def_tun_cost = tonumber(cm.get("babel", "tunnel", "rxcost") || 1) || 0;
let wgclients = 0;
cm.foreach("wireguard", "client",
    function(s) {
        const m1 = match(s.key, /^(.+=)(.+=)(.+=)(.+=)$/);
        const server_priv = m1[1];
        const client_pub = m1[4];
        const m2 = match(s.clientip, /^(\d+\.\d+\.\d+\.\d+):(\d+)$/);
        const addr = m2[1];
        const port = m2[2];
        const abcd = iptoarr(addr);
        const ll = network.mac2ipv6ll(sprintf("00:00:%02x:%02x:%02x:%02x", abcd[0], abcd[1], abcd[2], abcd[3])) + "/64";
        const w = s.cost || def_tun_cost;
        cfg.wireguard_network_config += sprintf("config interface 'wgc%d'\n\toption proto 'wireguard'\n\toption private_key '%s'\n\toption nohostroute '1'\n\toption cost '%s'\n\toption listen_port '%s'\n\tlist addresses '%s'\n\tlist addresses '%s'\n\toption disabled '%s'\n\n",
            wgclients, server_priv, w, port, addr, ll, (s.enabled == 1 ? "0" : "1"));
        cfg.wireguard_network_config += sprintf("config wireguard_wgc%d\n\toption public_key '%s'\n\toption persistent_keepalive '25'\n\tlist allowed_ips '0.0.0.0/0'\n\tlist allowed_ips '::/0'\n\n",
            wgclients, client_pub);
        cfg.vpn_interfaces += `\tlist network 'wgc${wgclients}'\n`;
        wgclients++;
    }
);
let wgservers = 0;
cm.foreach("wireguard", "server",
    function(s) {
        const m1 = match(s.passwd, /^(.+=)(.+=)(.+=)$/);
        const server_pub = m1[1];
        const client_priv = m1[2];
        const client_pub = m1[3];
        const m2 = match(s.netip, /^(\d+\.\d+\.\d+\.\d+):(\d+)/);
        const addr = m2[1];
        const abcd = iptoarr(addr);
        const p = m2[2];
        const ll = network.mac2ipv6ll(sprintf("00:00:%02x:%02x:%02x:%02x", abcd[0], abcd[1], abcd[2], abcd[3] + 1)) + "/64";
        const w = s.cost || def_tun_cost;
        cfg.wireguard_network_config += sprintf("config interface 'wgs%d'\n\toption proto 'wireguard'\n\toption private_key '%s'\n\toption nohostroute '1'\n\toption cost '%s'\n\tlist addresses '%d.%d.%d.%d'\n\tlist addresses '%s'\n\toption disabled '%s'\n\n",
            wgservers, client_priv, w, abcd[0], abcd[1], abcd[2], abcd[3] + 1, ll, (s.enabled == 1 ? "0" : "1"));
        cfg.wireguard_network_config += sprintf("config wireguard_wgs%d\n\toption public_key '%s'\n\toption endpoint_host '%s'\n\toption endpoint_port '%s'\n\toption persistent_keepalive '25'\n\tlist allowed_ips '0.0.0.0/0'\n\tlist allowed_ips '::/0'\n\n",
            wgservers, server_pub, s.host, p);
        wgservers++;
    }
);

// Put xlinks into dtdlink zone
if (fs.access("/etc/config.mesh/xlink")) {
    cm.foreach("xlink", "interface",
        function(section) {
            cfg.dtdlink_interfaces += `\n\tlist network '${section[".name"]}'`;
        }
    );
}

// NTP
if (cm.get("aredn", "@ntp[0]", "period") == "continually") {
    cfg.ntp_enabled = "1";
}

// Save the new configuration
removeAll("/tmp/new_config");
fs.mkdir("/tmp/new_config");

const md = fs.opendir("/etc/config.mesh");
if (md) {
    for (let bfile = md.read(); bfile; bfile = md.read()) {
        if (bfile == "setup" || bfile == "wireguard" || bfile == "xlink" | bfile == "firewall.user") {
            // Don't copy these
        }
        else {
            const f = fs.open(`/tmp/new_config/${bfile}`, "w");
            if (f) {
                f.write(expandVars(fs.readfile(`/etc/config.mesh/${bfile}`)));
                f.close();
            }
        }
    }
    md.close();
}

const nc = uci.cursor("/tmp/new_config");

// Append to firewall
const fw = fs.open("/tmp/new_config/firewall", "a");
if (fw) {
    if (!isNatMode()) {
        fw.write("\nconfig forwarding\n\toption src 'wifi'\n\toption dest 'lan'\n");
        fw.write("\nconfig forwarding\n\toption src 'dtdlink'\n\toption dest 'lan'\n");
        fw.write("\nconfig forwarding\n\toption src 'vpn'\n\toption dest 'lan'\n");
    }
    if (nc.get("aredn", "@wan[0]", "mesh_to_local_wan") == "1") {
        fw.write("\nconfig forwarding\n\toption src 'wifi'\n\toption dest 'wan'\n");
        fw.write("\nconfig forwarding\n\toption src 'dtdlink'\n\toption dest 'wan'\n");
        fw.write("\nconfig forwarding\n\toption src 'vpn'\n\toption dest 'wan'\n");
    }

    const ports = cm.get("setup", "ports", "port") || [];
    for (let p = 0; p < length(ports); p++) {
        const line = ports[p];
        const dip = match(line, /dmz_ip = ([\d\.]+)/);
        if (dip && isDmzMode()) {
            fw.write(`\nconfig redirect\n\toption src 'wifi'\n\toption proto 'tcp'\n\toption src_dip '${cfg.wifi_ip}'\n\toption dest_ip '${dip}'\n`);
            fw.write(`\nconfig redirect\n\toption src 'wifi'\n\toption proto 'udp'\n\toption src_dip '${cfg.wifi_ip}'\n\toption dest_ip '${dip}'\n`);
        }
        else {
            const m = match(line, /(.*):(.*):(.*):(.*):(.*):(.*)/);
            if (m[6] == "1") {
                let mt = `option src_dport '${m[3]}'\n`;
                if (m[2] == "tcp") {
                    mt += "\toption proto 'tcp'\n";
                }
                else if (m[2] == "udp") {
                    mt += "\toption proto 'udp'\n";
                }
                // uci the host and then
                // set the inside port unless the rule uses an outside port range
                let host = `option dest_ip ${m[4]}\n`;
                if (!match(m[3], /\-/)) {
                    host += `\toption dest_port '${m[5]}'\n`;
                }
                let intf = m[1];
                if (isDmzMode() && intf == "both") {
                    intf = "wan";
                }
                if (intf == "both") {
                    fw.write(`\nconfig redirect\n\toption src 'wifi'\n\toption dest 'lan'\n\t${match}\toption src_dip '${cfg.wifi_ip}'\n\t${host}\n`);
                    fw.write(`\nconfig redirect\n\toption src 'dtdlink'\n\toption dest 'lan'\n\t${match}\toption src_dip '${cfg.wifi_ip}'\n\t${host}\n`);
                    fw.write(`\nconfig redirect\n\toption src 'vpn'\n\toption dest 'lan'\n\t${match}\toption src_dip '${cfg.wifi_ip}'\n\t${host}\n`);
                    fw.write(`\nconfig redirect\n\toption src 'wan'\n\toption dest 'lan'\n\t${match}\t${host}\n`);
                }
                else if (intf == "wifi" && isNatMode()) {
                    fw.write(`\nconfig redirect\n\toption src 'wifi'\n\toption dest 'lan'\n\t${match}\toption src_dip '${cfg.wifi_ip}'\n\t${host}\n`);
                    fw.write(`\nconfig redirect\n\toption src 'dtdlink'\n\toption dest 'lan'\n\t${match}\toption src_dip '${cfg.wifi_ip}'\n\t${host}\n`);
                    fw.write(`\nconfig redirect\n\toption src 'vpn'\n\toption dest 'lan'\n\t${match}\toption src_dip '${cfg.wifi_ip}'\n\t${host}\n`);
                }
                else if (intf == "wan") {
                    fw.write(`\nconfig redirect\n\toption src 'dtdlink'\n\toption dest 'lan'\n\t${match}\toption src_dip '${cfg.wifi_ip}'\n\t${host}\n`);
                    fw.write(`\nconfig redirect\n\toption src 'wan'\n\toption dest 'lan'\n\t${match}\t${host}\n`);
                }
            }
        }
    }
    fw.close();
}

// setup nat
if (isNatMode()) {
    const masq_src = `${cfg.lan_ip}/${network.netmaskToCIDR(cfg.lan_mask)}`;
    for (let z = 2; z < 4; z++) {
        nc.set("firewall", `@zone[${z}]`, "masq", "1");
        nc.set("firewall", `@zone[${z}]`, "masq_src", masq_src);
    }
    nc.commit("firewall");
}

// setup node lan dhcp
function loadDhcpTags()
{
    const dhcpTags = {};
    const tags = cm.get("setup", "dhcptags", "tag") || [];
    for (let i = 0; i < length(tags); i++) {
        const m = match(tags[i], /([^ \t]+)[ \t]+([^ \t]+)[ \t]+(.*)/);
        if (m) {
            const sub = getSubtable(dhcpTags, m[2]);
            push(sub, { name: m[1], pattern: m[3] });
        }
    }
    return dhcpTags;
}

function loadDhcpOptions()
{
    const dhcpOptions = {};
    const opts = cm.get("setup", "dhcpoptions", "option") || [];
    for (let i = 0; i < length(opts); i++) {
        const m = match(opts[i], /([^ \t]*)[ \t]+([^ \t]+)[ \t]+(\d+)[ \t]+(.*)/);
        if (m) {
            const sub = getSubtable(dhcpOptions, m[1]);
            push(sub, { num: m[3], val: m[4] });
        }
    }
    return dhcpOptions;
}

function optionItem(tag, option)
{
    const parts = [];
    if (tag != "") {
        push(parts, `tag:${tag}`);
    }
    push(parts, option.num);
    if (option.val != "") {
        if (option.num == OPT_VENDOR_ID_ENCAP && !match(option.val, /^vi-encap:/)) {
            option.val = `${VI_ENCAP}${option.val}`;
        }
        push(parts, option.val);
    }
    return join(",", parts);
}

function createClassifiedSection(condition, cond_list)
{
    for (let i = 0; i < length(cond_list); i++) {
        const props = cond_list[i];
        let secname = condition;
        let pat = props.pattern;
        if (condition == "subscriberid") {
            secname = "subscrid";
            pat = `"${replace(pat, '"', '\\"')}"`;
        }
        nc.add("dhcp", secname);
        const section_ref = `@${secname}[${i}]`;
        nc.set("dhcp", section_ref, "networkid", props.name);
        nc.set("dhcp", section_ref, condition, pat);
    }
}

function createTagSection(tag, force, optlist)
{
    if (tag != "") {
        nc.set("dhcp", tag, "tag");
        if (force == FORCE) {
            nc.set("dhcp", tag, "force", "1");
        }
        const options = [];
        for (let i = 0; i < length(optlist); i++) {
            push(options, optionItem("", optlist[i])); // tag is on section
        }
        nc.set("dhcp", tag, "dhcp_option", options);
    }
}

// DHCP options start

// ...

nc.commit("dhcp");
// DHCP options end

// Generate the wireless config file
