#!/usr/bin/ucode
/*
 * Part of AREDN速 -- Used for creating Amateur Radio Emergency Data Networks
 * Copyright (C) 2024,2025 Tim Wilkinson
 * See Contributors file for additional contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Additional Terms:
 *
 * Additional use restrictions exist on the AREDN速 trademark and logo.
 * See AREDNLicense.txt for more info.
 *
 * Attributions to the AREDN速 Project must be retained in the source code.
 * If importing this code into a new or existing project attribution
 * to the AREDN速 project must be added to the source code.
 *
 * You must not misrepresent the origin of the material contained within.
 *
 * Modified versions must be modified to attribute to the original source
 * and be marked in reasonable ways as differentiate it from the original
 * version
 */

import * as fs from "fs";
import * as uci from "uci";
import * as hardware from "aredn.hardware";
import * as network from "aredn.network";
import * as services from "aredn.services";

// Helpers

function isNull(v)
{
    if (!v || v == "" || v == 0 || v == "0") {
        return true;
    }
    else {
        return false;
    }
}

function isNotNull(v)
{
    return !isNull(v);
}

function h2s(hexstr)
{
    let s = "";
    if (hex) {
        for (let i = 0; i < length(hexstr); i += 2) {
            const p = substr(hexstr, i, 2);
            if (match(p, /[0-9a-f][0-9a-f]/)) {
                s += chr(hex(p));
            }
            else {
                s += p;
            }
        }
    }
    return s;
}

function tonumber(v)
{
    if (v === "" || v === null) {
        return null;
    }
    return 1 * v;
}

function ip2decimal(ip)
{
    const a = iptoarr(ip);
    return (a[0] << 24) + (a[1] << 16) + (a[2] << 8) + a[3];
}

function decimal2ip(d)
{
    return arrtoip([(d >> 24) & 255, (d >> 16) & 255, (d >> 8) & 255, d & 255]);
}

function filecopy(from, to)
{
    const f = fs.readfile(from);
    if (f == null) {
        return false;
    }
    const t = fs.readfile(to);
    if (f == t) {
        return false;
    }
    fs.writefile(to, f);
    return true;
}

function getSubtable(container, key, dflt)
{
    let subtable = container[key];
    if (!subtable) {
        subtable = dflt;
        container[key] = subtable;
    }
    return subtable;
}

function removeAll(dir)
{
    system(`/bin/rm -rf ${dir}`);
}

// Helper end

const FORCED = "force";
const UNFORCED = "onrequest";
const OPT_RAPID_COMMIT = "80";
const OPT_VENDOR_ID_ENCAP = "125";
const VI_ENCAP = "vi-encap:";

const c = uci.cursor();
const cm = uci.cursor("/etc/config.mesh");
const nvram = uci.cursor("/etc/local/uci");

const ieee80211 = "/sys/class/ieee80211/";

const node = nvram.get("hsmmmesh", "settings", "node");
const tactical = nvram.get("hsmmmesh", "settings", "tactical");
const mac2 = nvram.get("hsmmmesh", "settings", "mac2");
const dtdmac = nvram.get("hsmmmesh", "settings", "dtdmac");

const is_supernode = cm.get("aredn", "@supernode[0]", "enable") == "1";
const wifi_mon_enable = false;
const deleteme = {};
const cfg = {
    description_node: "",
    lan_intf: hardware.getBoardNetworkInterfaceName("lan"),
    wan_intf: hardware.getBoardNetworkInterfaceName("wan"),
    bridge_network_config: "",
    lan_network_config: "",
    wan_network_config: "",
    dtdlink_network_config: "",
    wifi_network_config: "",
    wireguard_network_config: "",
    dtdlink_interfaces: "\tlist network 'dtdlink'",
    vpn_interfaces: "",
    tun_devices_config: "",
    ntp_enabled: "0"
};

// Track the changes so we can make better decissions about what to restart/reboot
const changes = {};

function validConfig(config) {
    removeAll("/tmp/uci_validate");
    fs.mkdir("/tmp/uci_validate");
    fs.writefile("/tmp/uci_validate/config", config);
    const r = system("/sbin/uci -c /tmp/uci_validate import dummy < /tmp/uci_validate/config") == 0;
    removeAll("/tmp/uci_validate");
    return r;
}

function isNatMode()
{
    return isNull(cfg.dmz_mode);
}

function isDmzMode()
{
    return isNotNull(cfg.dmz_mode) && cfg.dmz_mode != "1";
}

function isAltNetMode()
{
    return cfg.dmz_mode == "1";
}

function expandVars(contents)
{
    const lines = split(contents, "\n");
    const nlines = [];
    for (let i = 0; i < length(lines); i++) {
        let line = lines[i];
        const m = match(line, /^include[ \t]+([^ \t]+)$/);
        if (m) {
            if (fs.access(m[1])) {
                line = expandVars(fs.readfile(m[1]));
                if (!validConfig(line)) {
                    print(`Invalid config fragment: ${m[1]}\n`);
                    exit(1);
                }
            }
            else {
                line = null;
            }
        }
        else if (!match(line, /^#/)) {
            const params = match(line, /<([^ \t]+)>/g);
            if (params) {
                for (let p = 0; p < length(params); p++) {
                    const parm = params[p][1];
                    if (deleteme[parm]) {
                        line = null;
                    }
                    else if (parm == "NODE") {
                        line = replace(line, "<NODE>", node);
                    }
                    else if (parm == "MAC2") {
                        line = replace(line, "<MAC2>", mac2);
                    }
                    else if (parm == "DTDMAC") {
                        line = replace(line, "<DTDMAC>", dtdmac);
                    }
                    else if (cfg[parm]) {
                        line = replace(line, `<${parm}>`, cfg[parm]);
                    }
                    else {
                        line = null;
                    }
                }
            }
        }
        if (line != null) {
            push(nlines, line);
        }
    }
    return join("\n", nlines);
}

// Load the configuration
const cms = cm.get_all("setup", "globals") || {};
for (let k in cms) {
    if (!match(k, /^\./)) {
        cfg[k] = cms[k];
    }
}

// Select the mesh configuration
const default_mesh_distance = 80550; // 50.1 miles
let mesh_wifi = "br-nomesh";
let mesh_ssid = "";
let mesh_channel = "";
let mesh_chanbw = "";
let mesh_txpower = null;
let mesh_distance = "";
if (cfg.radio0_mode == "mesh" || cfg.radio0_mode == "meshap" || cfg.radio0_mode == "meshptp" || cfg.radio0_mode == "meshsta") {
    mesh_wifi = "wlan0";
    mesh_channel = tonumber(cfg.radio0_channel);
    mesh_chanbw = tonumber(cfg.radio0_bandwidth);
    mesh_ssid = cfg.radio0_ssid;
    mesh_txpower = tonumber(cfg.radio0_txpower);
    mesh_distance = tonumber(cfg.radio0_distance || 0);
}
else if (cfg.radio1_mode == "mesh" || cfg.radio1_mode == "meshap" || cfg.radio1_mode == "meshptp" || cfg.radio1_mode == "meshsta") {
    mesh_wifi = "wlan1";
    mesh_channel = tonumber(cfg.radio1_channel);
    mesh_chanbw = tonumber(cfg.radio1_bandwidth);
    mesh_ssid = cfg.radio1_ssid;
    mesh_txpower = tonumber(cfg.radio1_txpower);
    mesh_distance = tonumber(cfg.radio1_distance || 0);
}
if (mesh_distance == 0) {
    mesh_distance = default_mesh_distance;
}

// Delete some config lines if necessary
if (cfg.wan_proto != "static") {
    deleteme.wan_ip = true;
    deleteme.wan_gw = true;
    deleteme.wan_mask = true;
}
if (isDmzMode() || isAltNetMode() || cfg.wan_proto != "disabled") {
    deleteme.lan_gw = true;
}

// lan_dhcp sense is inverted in the dhcp config file
// and it is a checkbox so it may not be defined - this fixes that
if (cfg.lan_dhcp == "1") {
    cfg.lan_dhcp = 0;
}
else {
    cfg.lan_dhcp = 1;
}

// handle possible remote syslog
const remote_log = cm.get("aredn", "@remotelog[0]", "url") || "";
const pip = match(remote_log, /^(.+):\/\/(\d+\.\d+\.\d+\.\d+):(\d+)$/);
if (pip && (pip[1] == "tcp" || pip[1] == "udp") && (pip[3] > 0 && pip[3] < 65536) && iptoarr(pip[2])) {
    cfg.remote_log_proto = pip[1];
    cfg.remote_log_ip = pip[2];
    cfg.remote_log_port = int(pip[3]);
}
else {
    deleteme.remote_log_proto = true;
    deleteme.remote_log_ip = true;
    deleteme.remote_log_port = true;
}

// Sensible dmz_mode default
if (isNull(cfg.dmz_mode)) {
    cfg.dmz_mode = "0";
}

// switch to dmz values if needed
if (isDmzMode()) {
    cfg.lan_ip = cfg.dmz_lan_ip;
    cfg.lan_mask = cfg.dmz_lan_mask;
    cfg.dhcp_start = cfg.dmz_dhcp_start;
    cfg.dhcp_end = cfg.dmz_dhcp_end;
}
cfg.dhcp_limit = cfg.dhcp_end - cfg.dhcp_start + 1;

// verify that we have all the variables we need
const dcm = fs.opendir("/etc/config.mesh");
if (dcm) {
    for (let file = dcm.read(); file; file = dcm.read()) {
        if (file === "." || file === "..") {
            continue;
        }
        const f = fs.open(`/etc/config.mesh/${file}`);
        if (f) {
            for (let line = f.read("line"); length(line); line = f.read("line")) {
                if (!match(line, /^#/)) {
                    const params = match(line, /<([^ \t]+)>/g);
                    if (params) {
                        for (let p = 0; p < length(params); p++) {
                            const parm = params[p][1];
                            if (uc(parm) == parm) {
                                // nvram variable
                                if (!nvram.get("hsmmmesh", "settings", lc(parm))) {
                                    print(`WARNING: nv parameter '${parm}' in file '/etc/config.mesh/${file}' does not exist\n`);
                                }
                            }
                            else if (!(parm in cfg) && !deleteme[parm]) {
                                print(`WARNING: parameter '${parm}' in file '/etc/config.mesh/${file}' does not exist\n`);
                            }
                        }
                    }
                }
            }
            f.close();
        }
    }
    dcm.close();
}

// generate the bridge configuration
if (fs.access("/etc/aredn_include/bridge.network.user")) {
    cfg.bridge_network_config = expandVars(fs.readfile("/etc/aredn_include/bridge.network.user"));
    if (!validConfig(cfg.bridge_network_config)) {
        print("Invalid config fragment: /etc/aredn_include/bridge.network.user\n");
        exit(1);
    }
}
else {
    const list = {};
    const networks = [ "lan", "wan", "dtdlink" ];
    for (let i = 0; i < length(networks); i++) {
        const ports = split(hardware.getBoardNetworkInterfaceName(networks[i]), " ");
        for (let p = 0; p < length(ports); p++) {
            if (ports[p]) {
                list[replace(ports[p], /\..*$/, "")] = true;
            }
        }
    }
    let config = "config device\n\toption name 'br0'\n\toption type 'bridge'\n\toption vlan_filtering '1'\n";
    for (let port in list) {
        config += `\tlist ports '${port}'\n`;
    }
    cfg.bridge_network_config = config;
}

// generate the network configurations
const wan_wifi_enabled = (cfg.radio0_mode == "wan" || cfg.radio1_mode == "wan");
const cnetworks = [ "lan", "wan", "dtdlink", "wifi" ];
for (let i = 0; i < length(cnetworks); i++) {
    const net = cnetworks[i];
    let wireless = false;
    let config = "";
    // User override
    // Ignore wan override if wan wifi is enabled
    if (fs.access(`/etc/aredn_include/${net}.network.user`) && !(net == wan && wan_wifi_enabled)) {
        const f = fs.open(`/etc/aredn_include/fixedmac.${net}`);
        if (f) {
            for (let line = f.read("line"); length(line); line = f.read("line")) {
                const m = match(line, /option[ \t]+macaddr[ \t]+([^ \t]+)/);
                if (m) {
                    cfg[`${net}_mac`] = trim(m[1]);
                }
            }
            f.close();
        }
        config = expandVars(fs.readfile(`/etc/aredn_include/${net}.network.user`));
        if (!validConfig(config)) {
            print("Invalid config fragment: /etc/aredn_include/${net}.network.user\n");
            exit(1);
        }
    }
    else {
        // generate a complete config
        let vlan = null;
        let ports = split(hardware.getBoardNetworkInterfaceName(net), " ");

        if (net == "lan") {
            // If the LAN has be given a vlan to use (usually by a switch) we use that here,
            // otherwise we just use '3'
            const lvlan = match(ports[0], /\.(\d+)$/);
            if (lvlan) {
                vlan = `${lvlan[1]}:t`;
            }
            else {
                vlan = "3:u";
            }
            // handle lan vlan override
            const m = match(cm.get("setup", "globals", "lan_intf") || "", /^([a-zA-Z0-9]+)(\.?)(\d*)$/);
            if (m) {
                if (m[2] === ".") {
                    vlan = `${m[3]}:t`;
                    ports = [ `${m[1]}.${m[3]}` ];
                }
                else {
                    vlan = `3:u`;
                    ports = [ `${m[1]}` ];
                }
            }
        }
        else if (net == "wan") {
            // wifi can be used for the WAN (we become a wifi client)
            if (cfg.radio0_mode == "wan") {
                wireless = true;
                ports = [ "wlan0" ];
            }
            else if (cfg.radio1_mode == "wan") {
                wireless = true;
                ports = [ "wlan1" ];
            }
            else {
                // If the WAN has been given a vlan to use (usually 1) we use that here.
                const wvlan = match(ports[0], /\.(\d+)$/);
                if (wvlan) {
                    vlan = `${wvlan[1]}:t`;
                }
                else {
                    vlan = "4:u";
                }
                // handle wan vlan override
                const m = match(cm.get("setup", "globals", "wan_intf") || "", /^([a-zA-Z0-9]+)(\.?)(\d*)$/);
                if (m) {
                    if (m[2] === ".") {
                        vlan = `${m[3]}:t`;
                        ports = [ `${m[1]}.${m[3]}` ];
                    }
                    else {
                        vlan = `4:u`;
                        ports = [ `${m[1]}` ];
                    }
                }
            }
        }
        else if (net == "dtdlink") {
            // Always vlan 2
            vlan = "2:t";
            cfg.dtdlink_proto = "static";
            cfg.dtdlink_mask = "255.0.0.0";
        }
        else if (net == "wifi") {
            wireless = true;
            cfg.wifi_proto = "static";
            ports = [ mesh_wifi ];
        }

        if (vlan) {
            // Vlan configuration
            const m = match(vlan, /(.*):(.*)/);
            config += `\nconfig bridge-vlan\n\toption device 'br0'\n\toption vlan '${m[1]}'\n`;
            for (let p = 0; p < length(ports); p++) {
                config += `\tlist ports '${replace(ports[p], /\..*$/, "")}:${m[2]}'\n`;
            }
            config += "\n";
            ports = [ `br0.${m[1]}` ];
        }

        let proto = cfg[`${net}_proto`] || "";
        let ipaddr = deleteme[`${net}_ip`] ? "" : (cfg[`${net}_ip`] || "");
        let netmask = deleteme[`${net}_mask`] ? "" : (cfg[`${net}_mask`] || "");
        let mtu = cfg[`${net}_mtu`] || "";
        let dns1 = "";
        let dns2 = "";
        if (net == "wifi") {
            dns1 = cfg.wan_dns1 || "";
            dns2 = cfg.wan_dns2 || "";
        }
        let gateway = deleteme[`${net}_gw`] ? "" : (cfg[`${net}_gw`] || "");
        
        config += "config device\n";
        if (!wireless) {
            config += `\toption name 'br-${net}'\n\toption type 'bridge'\n`;
        }
        else if (net !== "wan") {
            netmask = "255.255.255.255";
        }
        if (fs.access(`/etc/aredn_include/fixedmac.${net}`)) {
            config += fs.readfile(`/etc/aredn_include/fixedmac.${net}`);
        }

        if (!wireless) {
            if (length(ports) == 0) {
                config += "\toption bridge_empty '1'\n";
            }
            else {
                for (let p = 0; p < length(ports); p++) {
                    config += `\tlist ports '${ports[p]}'\n`;
                }
            }
        }
        else {
            config += `\toption name '${ports[0]}'\n`;
            if (!match(ports[0], /^wlan/)) {
                config += "\toption type 'bridge'\n\toption bridge_empty '1'\n";
            }
        }

        config += `\nconfig interface ${net}\n`;
        if (wireless) {
            config += `\toption device '${ports[0]}'\n`;
        }
        else {
            config += `\toption device 'br-${net}'\n`;
        }
        if (proto != "") {
            config += `\toption proto '${proto}'\n`;
        }
        if (mtu != "") {
            config += `\toption mtu '${mtu}'\n`;
        }
        if (ipaddr != "") {
            config += `\toption ipaddr '${ipaddr}'\n`;
        }
        if (netmask != "") {
            config += `\toption netmask '${netmask}'\n`;
        }
        if (dns1 != "" || dns2 != "") {
            config += `\toption dns '${dns1 || ""}${dns1 && dns2 ? " " : ""}${dns2 || ""}'\n`;
        }
        if (gateway != "") {
            config += `\toption gateway '${gateway}'\n`;
        }
    }
    cfg[`${net}_network_config`] = config;
}

// Generate the tunnel configurations
let wg_begin = cm.get("wireguard", "@network[0]", "begin");
if (is_supernode && wg_begin && match(wg_begin, /^172\.31\./)) {
    wg_begin = `172.30.${substr(wg_begin, 8)}`;
    cm.set("wireguard", "@network[0]", "begin", wg_begin);
    cm.commit("wireguard");
}
const def_tun_cost = tonumber(cm.get("babel", "tunnel", "rxcost") || 1) || 0;
let wgclients = 0;
cm.foreach("wireguard", "client",
    function(s) {
        const m1 = match(s.key, /^(.+=)(.+=)(.+=)(.+=)$/);
        const server_priv = m1[1];
        const client_pub = m1[4];
        const m2 = match(s.clientip, /^(\d+\.\d+\.\d+\.\d+):(\d+)$/);
        const addr = m2[1];
        const port = m2[2];
        const abcd = iptoarr(addr);
        const ll = network.mac2ipv6ll(sprintf("00:00:%02x:%02x:%02x:%02x", abcd[0], abcd[1], abcd[2], abcd[3])) + "/64";
        const w = s.cost || def_tun_cost;
        cfg.wireguard_network_config += sprintf("config interface 'wgc%d'\n\toption proto 'wireguard'\n\toption private_key '%s'\n\toption nohostroute '1'\n\toption cost '%s'\n\toption listen_port '%s'\n\tlist addresses '%s'\n\tlist addresses '%s'\n\toption disabled '%s'\n\n",
            wgclients, server_priv, w, port, addr, ll, (s.enabled == 1 ? "0" : "1"));
        cfg.wireguard_network_config += sprintf("config wireguard_wgc%d 'wireguard_wgc%d'\n\toption public_key '%s'\n\toption persistent_keepalive '25'\n\tlist allowed_ips '0.0.0.0/0'\n\tlist allowed_ips '::/0'\n\n",
            wgclients, wgclients, client_pub);
        cfg.vpn_interfaces += `\tlist network 'wgc${wgclients}'\n`;
        wgclients++;
    }
);
let wgservers = 0;
cm.foreach("wireguard", "server",
    function(s) {
        const m1 = match(s.passwd, /^(.+=)(.+=)(.+=)$/);
        const server_pub = m1[1];
        const client_priv = m1[2];
        const client_pub = m1[3];
        const m2 = match(s.netip, /^(\d+\.\d+\.\d+\.\d+):(\d+)/);
        const addr = m2[1];
        const abcd = iptoarr(addr);
        const p = m2[2];
        const ll = network.mac2ipv6ll(sprintf("00:00:%02x:%02x:%02x:%02x", abcd[0], abcd[1], abcd[2], abcd[3] + 1)) + "/64";
        const w = s.cost || def_tun_cost;
        cfg.wireguard_network_config += sprintf("config interface 'wgs%d'\n\toption proto 'wireguard'\n\toption private_key '%s'\n\toption nohostroute '1'\n\toption cost '%s'\n\tlist addresses '%d.%d.%d.%d'\n\tlist addresses '%s'\n\toption disabled '%s'\n\n",
            wgservers, client_priv, w, abcd[0], abcd[1], abcd[2], abcd[3] + 1, ll, (s.enabled == 1 ? "0" : "1"));
        cfg.wireguard_network_config += sprintf("config wireguard_wgs%d 'wireguard_wgs%d'\n\toption public_key '%s'\n\toption endpoint_host '%s'\n\toption endpoint_port '%s'\n\toption persistent_keepalive '25'\n\tlist allowed_ips '0.0.0.0/0'\n\tlist allowed_ips '::/0'\n\n",
            wgservers, wgservers, server_pub, s.host, p);
        cfg.vpn_interfaces += `\tlist network 'wgs${wgservers}'\n`;
        wgservers++;
    }
);

// Put xlinks into dtdlink zone
if (fs.access("/etc/config.mesh/xlink")) {
    cm.foreach("xlink", "interface",
        function(section) {
            cfg.dtdlink_interfaces += `\n\tlist network '${section[".name"]}'`;
        }
    );
}

// NTP
if (cm.get("aredn", "@ntp[0]", "period") == "continually") {
    cfg.ntp_enabled = "1";
}

// Save the new configuration
removeAll("/tmp/new_config");
fs.mkdir("/tmp/new_config");

const md = fs.opendir("/etc/config.mesh");
if (md) {
    for (let bfile = md.read(); bfile; bfile = md.read()) {
        if (bfile == "setup" || bfile == "wireguard" || bfile == "xlink" || bfile == "firewall.user") {
            // Don't copy these
        }
        else {
            const f = fs.open(`/tmp/new_config/${bfile}`, "w");
            if (f) {
                f.write(expandVars(fs.readfile(`/etc/config.mesh/${bfile}`)));
                f.close();
            }
        }
    }
    md.close();
}

const nc = uci.cursor("/tmp/new_config");

// Append to firewall
const fw = fs.open("/tmp/new_config/firewall", "a");
if (fw) {
    if (!isNatMode()) {
        fw.write("\nconfig forwarding\n\toption src 'wifi'\n\toption dest 'lan'\n");
        fw.write("\nconfig forwarding\n\toption src 'dtdlink'\n\toption dest 'lan'\n");
        fw.write("\nconfig forwarding\n\toption src 'vpn'\n\toption dest 'lan'\n");
    }
    if (nc.get("aredn", "@wan[0]", "mesh_to_local_wan") == "1") {
        fw.write("\nconfig forwarding\n\toption src 'wifi'\n\toption dest 'wan'\n");
        fw.write("\nconfig forwarding\n\toption src 'dtdlink'\n\toption dest 'wan'\n");
        fw.write("\nconfig forwarding\n\toption src 'vpn'\n\toption dest 'wan'\n");
    }

    const ports = cm.get("setup", "ports", "port") || [];
    for (let p = 0; p < length(ports); p++) {
        const line = ports[p];
        const dip = match(line, /dmz_ip = ([\d\.]+)/);
        if (dip && isDmzMode()) {
            fw.write(`\nconfig redirect\n\toption src 'wifi'\n\toption proto 'tcp'\n\toption src_dip '${cfg.wifi_ip}'\n\toption dest_ip '${dip}'\n`);
            fw.write(`\nconfig redirect\n\toption src 'wifi'\n\toption proto 'udp'\n\toption src_dip '${cfg.wifi_ip}'\n\toption dest_ip '${dip}'\n`);
        }
        else {
            const m = match(line, /(.*):(.*):(.*):(.*):(.*):(.*)/);
            if (m[6] == "1") {
                let mt = `option src_dport '${m[3]}'\n`;
                if (m[2] == "tcp") {
                    mt += "\toption proto 'tcp'\n";
                }
                else if (m[2] == "udp") {
                    mt += "\toption proto 'udp'\n";
                }
                // uci the host and then
                // set the inside port unless the rule uses an outside port range
                let host = `option dest_ip ${m[4]}\n`;
                if (!match(m[3], /\-/)) {
                    host += `\toption dest_port '${m[5]}'\n`;
                }
                let intf = m[1];
                if (isDmzMode() && intf == "both") {
                    intf = "wan";
                }
                if (intf == "both") {
                    fw.write(`\nconfig redirect\n\toption src 'wifi'\n\toption dest 'lan'\n\t${mt}\toption src_dip '${cfg.wifi_ip}'\n\t${host}\n`);
                    fw.write(`\nconfig redirect\n\toption src 'dtdlink'\n\toption dest 'lan'\n\t${mt}\toption src_dip '${cfg.wifi_ip}'\n\t${host}\n`);
                    fw.write(`\nconfig redirect\n\toption src 'vpn'\n\toption dest 'lan'\n\t${mt}\toption src_dip '${cfg.wifi_ip}'\n\t${host}\n`);
                    fw.write(`\nconfig redirect\n\toption src 'wan'\n\toption dest 'lan'\n\t${mt}\t${host}\n`);
                }
                else if (intf == "wifi" && isNatMode()) {
                    fw.write(`\nconfig redirect\n\toption src 'wifi'\n\toption dest 'lan'\n\t${mt}\toption src_dip '${cfg.wifi_ip}'\n\t${host}\n`);
                    fw.write(`\nconfig redirect\n\toption src 'dtdlink'\n\toption dest 'lan'\n\t${mt}\toption src_dip '${cfg.wifi_ip}'\n\t${host}\n`);
                    fw.write(`\nconfig redirect\n\toption src 'vpn'\n\toption dest 'lan'\n\t${mt}\toption src_dip '${cfg.wifi_ip}'\n\t${host}\n`);
                }
                else if (intf == "wan") {
                    fw.write(`\nconfig redirect\n\toption src 'wan'\n\toption dest 'lan'\n\t${mt}\t${host}\n`);
                }
            }
        }
    }
    fw.close();
}

// setup nat
if (isNatMode()) {
    const masq_src = `${cfg.lan_ip}/${network.netmaskToCIDR(cfg.lan_mask)}`;
    for (let z = 2; z < 4; z++) {
        nc.set("firewall", `@zone[${z}]`, "masq", "1");
        nc.set("firewall", `@zone[${z}]`, "masq_src", masq_src);
    }
    nc.commit("firewall");
}

// setup node lan dhcp
function loadDhcpTags()
{
    const dhcpTags = {};
    const tags = cm.get("setup", "dhcptags", "tag") || [];
    for (let i = 0; i < length(tags); i++) {
        const m = match(tags[i], /([^ \t]+)[ \t]+([^ \t]+)[ \t]+(.*)/);
        if (m) {
            const sub = getSubtable(dhcpTags, m[2], []);
            push(sub, { name: m[1], pattern: m[3] });
        }
    }
    return dhcpTags;
}

function loadDhcpOptions()
{
    const dhcpOptions = {};
    const opts = cm.get("setup", "dhcpoptions", "option") || [];
    for (let i = 0; i < length(opts); i++) {
        const m = match(opts[i], /([^ \t]*)[ \t]+([^ \t]+)[ \t]+(\d+)[ \t]+(.*)/);
        if (m) {
            const bytag = getSubtable(dhcpOptions, m[1], {});
            push(getSubtable(bytag, m[2], []), { num: m[3], val: m[4] });
        }
    }
    return dhcpOptions;
}

function optionItem(tag, option)
{
    const parts = [];
    if (tag != "") {
        push(parts, `tag:${tag}`);
    }
    push(parts, option.num);
    if (option.val != "") {
        if (option.num == OPT_VENDOR_ID_ENCAP && !match(option.val, /^vi-encap:/)) {
            option.val = `${VI_ENCAP}${option.val}`;
        }
        push(parts, option.val);
    }
    return join(",", parts);
}

function createClassifiedSection(condition, cond_list)
{
    for (let i = 0; i < length(cond_list); i++) {
        const props = cond_list[i];
        let secname = condition;
        let pat = props.pattern;
        if (condition == "subscriberid") {
            secname = "subscrid";
            pat = `"${replace(pat, '"', '\\"')}"`;
        }
        nc.add("dhcp", secname);
        const section_ref = `@${secname}[${i}]`;
        nc.set("dhcp", section_ref, "networkid", props.name);
        nc.set("dhcp", section_ref, condition, pat);
    }
}

function createTagSection(tag, force, optlist)
{
    if (tag != "") {
        nc.set("dhcp", tag, "tag");
        if (force == FORCED) {
            nc.set("dhcp", tag, "force", "1");
        }
        const options = [];
        for (let i = 0; i < length(optlist); i++) {
            push(options, optionItem("", optlist[i])); // tag is on section
        }
        nc.set("dhcp", tag, "dhcp_option", options);
    }
}

// DHCP options

const dhcp_option_list = [];
const dhcp_option_force_list = [];
let route44net = "";
if (nc.get("aredn", "@wan[0]", "lan_dhcp_44route") == "1" && fs.access("/etc/44net.conf")) {
    const f = fs.open("/etc/44net.conf");
    if (f) {
        for (let line = f.read("line"); length(line); line = f.read("line")) {
            route44net += `,${trim(line)},${cfg.lan_ip}`;
        }
        f.close();
    }
}
if (nc.get("aredn", "@wan[0]", "lan_dhcp_route") == "1" || nc.get("aredn", "@wan[0]", "lan_dhcp_defaultroute") == "1" || nc.get("aredn", "@wan[0]", "lan_to_remote_wan") == "1") {
    // Provide stateless routes and default route
    push(dhcp_option_list, `121,10.0.0.0/8,${cfg.lan_ip}${route44net},0.0.0.0/0,${cfg.lan_ip}`);
    push(dhcp_option_list, `249,10.0.0.0/8,${cfg.lan_ip}${route44net},0.0.0.0/0,${cfg.lan_ip}`);
}
else {
    // Provide stateless routes to the mesh, and a blank default route (option 3 has no values) to
    // suppress default route being sent
    push(dhcp_option_list, `121,10.0.0.0/8,${cfg.lan_ip}${route44net}`);
    push(dhcp_option_list, `249,10.0.0.0/8,${cfg.lan_ip}${route44net}`);
    push(dhcp_option_list, `3`);
}

const advancedOptions = loadDhcpOptions();
const dhcpTags = loadDhcpTags();
nc.load("dhcp");
for (let condition in dhcpTags) {
    createClassifiedSection(condition, dhcpTags[condition]);
}
for (let tag in advancedOptions) {
    const forcelist = advancedOptions[tag];
    if (forcelist) {
        // tag-section name cannot be empty or section name must be unique
        if (tag == "" || length(forcelist) > 1) {
            // place unforced options in the anonymous section
            for (let i = 0; i < length(forcelist[UNFORCED] || []); i++) {
                const option = forcelist[UNFORCED][i];
                push(dhcp_option_list, optionItem(tag, option));
                // If we detect a rapid-commit option to enable the necessary config flag
                if (option.num == OPT_RAPID_COMMIT) {
                    nc.set("dhcp", "@dhcp[0]", "rapidcommit", "1");
                }
            }
            delete forcelist[UNFORCED];
            for (let i = 0; i < length(forcelist[FORCED] || []); i++) {
                const option = forcelist[FORCED][i];
                push(dhcp_option_force_list, optionItem(tag, option));
                // If we detect a rapid-commit option to enable the necessary config flag
                if (option.num == OPT_RAPID_COMMIT) {
                    nc.set("dhcp", "@dhcp[0]", "rapidcommit", "1");
                }
            }
            delete forcelist[FORCED];
        }
        for (let force in forcelist) {
            createTagSection(tag, force, forcelist[force]);
        }
    }
}
if (length(dhcp_option_list) > 0) {
    nc.set("dhcp", "@dhcp[0]", "dhcp_option", dhcp_option_list);
}
if (length(dhcp_option_force_list) > 0) {
    nc.set("dhcp", "@dhcp[0]", "dhcp_option_force", dhcp_option_force_list);
}
nc.commit("dhcp");

// Generate the wireless config file
let config = "";
const ifacecount = hardware.getRadioCount();
const devpaths = {};
for (let dev = 0; dev < ifacecount; dev++) {
    const devname = `phy${dev}`;
    const radio = `radio${dev}`;
    const wlan = `wlan${dev}`;
    let devpath = match(fs.realpath(`${ieee80211}${fs.readlink(ieee80211 + devname)}`), /^\/sys\/devices\/(.*)\/ieee802.*$/);
    if (!devpath) {
        continue;
    }
    if (match(devpath[1], /^platform.*\/pci.*/)) {
        devpath = match(devpath[1], /^platform\/(.*)/);
    }
    devpath = devpath[1];
    const devpathc = devpaths[devpath] || 0;
    devpaths[devpath] = devpathc + 1;
    if (devpathc > 0) {
        devpath += `+${devpathc}`;
    }
    const rif = hardware.getRadioIntf(wlan);
    if (!rif || rif.disabled) {
        config += `config wifi-device '${radio}'\n\toption type 'mac80211'\n\toption disabled '1'\n\toption path '${devpath}'\n\n`;
    }
    else {
        let type = "mac80211";
        let disabled = "0";
        let chanbw = null;
        let country = null;
        let channel = null;
        let distance = null;
        let network = null;
        let mode = null;
        let ssid = null;
        let encryption = null;
        let key = null;
        let celldensity = null;
        let txpower = null;
        let rssireject = null;
        let multicasttounicast = null;
        let macfilter = null;
        let macaddr = null;
        let isolate = null;
        let disassoclowack = null;
        let maxinactivity = null;
        let maxlisteninterval = null;
        let uapsd = null;
        let hwmode = null;
        let bcf = null;
        let htmode = hardware.getHTMode(wlan, wlan == mesh_wifi ? mesh_chanbw : -1, cfg[`${radio}_mode`]);

        switch (hardware.getDefaultChannel(wlan)?.band) {
            case "3GHz":
            case "5GHz":
                hwmode = "11a";
                break;
            case "HaLow":
                hwmode = "11ah";
                type = "morse";
                country = "US";
                if (rif.bcf) {
                    bcf = rif.bcf;
                }
                break;
            default:
                hwmode = "11g";
                break;
        }
        if (cfg[`${radio}_mode`] == "mesh") {
            // mesh RF adhoc configuration
            is_mesh_rf = true;
            channel = mesh_channel;
            chanbw = mesh_chanbw;
            country = country ?? "HX";
            txpower = mesh_txpower;
            distance = mesh_distance;
            if (hwmode == "11ah") {
                ssid = `${mesh_ssid}-${channel}-${chanbw}-v3`;
            }
            else {
                ssid = `${mesh_ssid}-${chanbw}-v3`;
            }
            mode = "adhoc";
            encryption = "none";
            network = "wifi";
        }
        else if (cfg[`${radio}_mode`] == "meshap" || cfg[`${radio}_mode`] == "meshptp") {
            // mesh RF access point configuration
            is_mesh_rf = true;
            channel = mesh_channel;
            chanbw = mesh_chanbw;
            txpower = mesh_txpower;
            distance = mesh_distance;
            ssid = `${mesh_ssid}-${channel}-${chanbw}-v3`;
            mode = "ap";
            encryption = "none";
            network = "wifi";
            multicasttounicast = 1;
            disassoclowack = 0;
            maxinactivity = 600;
            maxlisteninterval = 1;
            uapsd = 0;
            if (cfg[`${radio}_mode`] == "meshptp") {
                macfilter = "allow";
            }
            else {
                macfilter = "deny";
            }
            // Make AP's the best for better arednlink performance
            macaddr = fs.readfile(`/sys/class/ieee80211/${devname}/macaddress`);
            if (macaddr) {
                macaddr = trim(replace(macaddr, /^..:/, "fe:"));
                isolate = 1;
            }
        }
        else if (cfg[`${radio}_mode`] == "meshsta") {
            // mesh RF station configuration
            is_mesh_rf = true;
            // While the wifi doesnt neeed 'channel' and 'chanbw' to configure the station, we read these values in other code so keep them
            channel = mesh_channel;
            chanbw = mesh_chanbw;
            distance = mesh_distance;
            txpower = mesh_txpower;
            ssid = `${mesh_ssid}-${mesh_channel}-${mesh_chanbw}-v3`;
            mode = "sta";
            encryption = "none";
            network = "wifi";
        }
        else if (cfg[`${radio}_mode`] == "lan") {
            // lan AP interface
            channel = cfg[`${radio}_channel`];
            ssid = h2s(cfg[`${radio}_ssid`]);
            mode = "ap";
            encryption = cfg[`${radio}_encryption`];
            key = h2s(cfg[`${radio}_key`]);
            network = "lan";
            if (hwmode == "11ah") {
                chanbw = cfg[`${radio}_bandwidth`];;
            }
        }
        else if (cfg[`${radio}_mode`] == "wan") {
            // wan client
            ssid = h2s(cfg[`${radio}_ssid`]);
            mode = "sta";
            if (cfg[`${radio}_key`] && cfg[`${radio}_key`] != "") {
                encryption = "psk2";
                key = h2s(cfg[`${radio}_key`]);
            }
            else {
                encryption = "none";
            }
            network = "wan";
            htmode = null;
        }
        else {
            disabled = "1";
        }

        config += `config wifi-device '${radio}'\n\toption type '${type}'\n`;
        config += `\toption disabled '${disabled}'\n`;
        if (channel != null) {
            config += `\toption channel '${channel}'\n`;
        }
        if (chanbw != null) {
            config += `\toption chanbw '${chanbw}'\n`;
        }
        if (country != null) {
            config += `\toption country '${country}'\n`;
        }
        if (distance != null) {
            config += `\toption distance '${distance}'\n`;
        }
        if (txpower != null) {
            config += `\toption txpower '${txpower}'\n`;
        }
        switch (hwmode) {
            case "11g":
                config += `\toption band '2g'\n`;
                break;
            case "11ah":
                config += `\toption band 's1g'\n\toption hwmode '11ah'\n`;
                break;
            default:
                config += `\toption band '5g'\n`;
                break;
        }
        if (htmode != null) {
            config += `\toption htmode '${htmode}'\n`;
        }
        if (celldensity != null) {
            config += `\toption cell_density '${celldensity}'\n`;
        }
        if (rssireject != null) {
            config += `\toption rssi_reject_assoc_rssi '${rssireject}'\n\toption rssi_ignore_probe_request '${rssireject}'\n`;
        }
        config += `\toption path '${devpath}'\n`;
        if (bcf != null) {
            config += `\toption bcf '${bcf}'\n\toption reconf '0'\n`;
        }
        config += `\n`;

        config += "config wifi-iface\n";
        config += `\toption ifname '${wlan}'\n`;
        config += `\toption device '${radio}'\n`;
        if (network != null) {
            config += `\toption network '${network}'\n`;
        }
        if (mode != null) {
            config += `\toption mode '${mode}'\n`;
        }
        if (ssid != null) {
            config += `\toption ssid '${ssid}'\n`;
        }
        if (macaddr != null) {
            config += `\toption macaddr '${macaddr}'\n`;
        }
        if (encryption != null) {
            config += `\toption encryption '${encryption}'\n`;
        }
        if (key != null) {
            config += `\toption key '${key}'\n`;
        }
        if (multicasttounicast != null) {
            config += `\toption multicast_to_unicast_all '${multicasttounicast}'\n`;
        }
        if (macfilter != null) {
            config += `\toption macfilter '${macfilter}'\n`;
        }
        if (isolate != null) {
            config += `\toption isolate '${isolate}'\n`;
        }
        if (disassoclowack != null) {
            config += `\toption disassoc_low_ack '${disassoclowack}'\n`;
        }
        if (maxinactivity != null) {
            config += `\toption max_inactivity '${maxinactivity}'\n`;
        }
        if (maxlisteninterval != null) {
            config += `\toption max_listen_interval '${maxlisteninterval}'\n`;
        }
        if (uapsd != null) {
            config += `\toption uapsd '${uapsd}'\n`;
        }

        config += "\n";

        if (is_mesh_rf && wifi_mon_enable) {
            config += "config wifi-iface\n";
            config += `\toption ifname '${wlan}-1'\n`;
            config += `\toption device '${radio}'\n`;
            config += `\toption network 'wifi_mon'\n\toption mode 'monitor'\n\n`;
        }
    }
}
fs.writefile("/tmp/new_config/wireless", config);

// Generate the host and ethers files
const h = fs.open("/etc/hosts", "w");
const e = fs.open("/etc/ethers", "w");
const ah = fs.open("/tmp/arednlink.hosts", "w");
if (h && e && ah) {
    h.write("# automatically generated file - do not edit\n");
    h.write("# use /etc/hosts.user for custom entries\n");
    h.write("127.0.0.1\tlocalhost\n");
    if (isNotNull(cfg.wifi_ip)) {
        h.write(`${cfg.lan_ip}\tlocalnode\n`);
        h.write(`${cfg.wifi_ip}\t${node} ${tactical || ""}\n`);
        ah.write(`${cfg.wifi_ip}\t${node}\n`);
        ah.write(`${cfg.lan_ip}\tlan.${node}.local.mesh\n`);
    }
    else {
        h.write(`${cfg.lan_ip}\tlocalnode ${node} ${tactical || ""}\n`);
    }
    if (isNotNull(cfg.dtdlink_ip)) {
        h.write(`${cfg.dtdlink_ip}\tdtdlink.${node}.local.mesh dtdlink.${node}\n`);
        ah.write(`${cfg.dtdlink_ip}\tdtdlink.${node}.local.mesh\n`);
    }

    // Mark supernodes so we can find them
    if (is_supernode && isNotNull(cfg.wifi_ip)) {
        ah.write(`${cfg.wifi_ip}\tsupernode.${node}.local.mesh\n`);
    }

    e.write("# automatically generated file - do not edit\n");
    e.write("# use /etc/ethers.user for custom entries\n");

    let netaddr = ip2decimal(cfg.lan_ip) & ip2decimal(cfg.lan_mask);
    // In NAT or AltNET mode the DHCP start can be something other than 2 which is what is assumed in the
    //  code which creates the DHCP reservations. So we adjust our netaddr base to account for this
    if (isNatMode() || isAltNetMode()) {
        netaddr += cfg.dhcp_start - 2;
    }

    const reservations = cm.get("setup", "dhcpreservations", "reservation") || [];
    for (let i = 0; i < length(reservations); i++) {
        const m = match(reservations[i], /([^ \t]+)[ \t]+([^ \t]+)[ \t]+([^ \t]+)[ \t]*([^ \t]*)/);
        if (m) {
            const ip = decimal2ip(netaddr + int(m[2]));
            h.write(`${ip}\t${m[3]} ${m[4]}\n`);
            e.write(`${m[1]}\t${ip}\n`);
            if (m[4] == "") {
                ah.write(`${ip}\t${m[3]}\n`);
            }
        }
    }

    // aliases need to ba added to /etc/hosts or they will now show up on the localnode
    // nor will the services they offer
    // also add a comment to the hosts file so we can display the aliases differently if needed
    const aliases = cm.get("setup", "aliases", "alias") || [];
    for (let i = 0; i < length(aliases); i++) {
        const m = match(aliases[i], /([^ \t]+)[ \t]+([^ \t]+)/);
        if (m) {
            let host = m[2];
            ah.write(`${m[1]}\t${host}\n`);
            if (!match(host, /\./)) {
                host += ".local.mesh";
            }
            h.write(`${m[1]}\t${host} #ALIAS\n`);
        }
    }

    h.write("\n");

    let f = fs.open("/etc/hosts.user");
    if (f) {
        for (let line = f.read("line"); length(line); line = f.read("line")) {
            h.write(line);
            ah.write(line);
        }
        f.close();
    }
    f = fs.open("/etc/ethers.user");
    if (f) {
        for (let line = f.read("line"); length(line); line = f.read("line")) {
            e.write(line);
        }
        f.close();
    }

    h.close();
    e.close();
    ah.close();
}

// Generate user blocks
const bd = fs.open("/tmp/babel-deny.conf", "w");
if (bd) {
    const blocks = split(cm.get("aredn", "@lqm[0]", "user_blocks"), ",");
    for (let i = 0; i < length(blocks); i++) {
        const mac = replace(replace(blocks[i], /[ \t]/, ""), "-", ":");
        const ll = network.mac2ipv6ll(mac);
        bd.write(`in anyproto neigh ${ll} deny\n`);
    }
    bd.close();
    if (filecopy("/tmp/babel-deny.conf", "/etc/aredn_include/babel-deny.conf")) {
        changes.babel = true;
    }
    fs.unlink("/tmp/babel-deny.conf");
}

// Reset validation state when we regenerate configs
services.resetValidation();

// Update services
const as = fs.open("/tmp/arednlink.services", "w");
if (as) {
    const info = services.get(false);
    for (let i = 0; i < length(info.services); i++) {
        as.write(`${info.services[i]}\n`);
    }
    as.close();
}

// Update arednlink
if (filecopy("/tmp/arednlink.hosts", "/etc/arednlink/hosts")) {
    changes.arednlink = true;
}
if (filecopy("/tmp/arednlink.services", "/etc/arednlink/services")) {
    changes.arednlink = true;
}
fs.unlink("/tmp/arednlink.hosts");
fs.unlink("/tmp/arednlink.services");

// Update user firewall
if (filecopy("/etc/config.mesh/firewall.user", "/etc/firewall.user")) {
    changes.firewall = true;
}

// Update services script
const sf = fs.open("/tmp/local_services", "w");
if (sf) {
    sf.write("#!/bin/sh\n");
    if (mesh_wifi != "br-nomesh") {
        if (isNull(mesh_txpower) || mesh_txpower > hardware.getMaxTxPower(mesh_wifi, mesh_channel)) {
            mesh_txpower = hardware.getMaxTxPower(mesh_wifi, mesh_channel);
        }
        else if (mesh_txpower < 1) {
            mesh_txpower = 1;
        }
        sf.write(`/usr/sbin/iw ${hardware.getPhyDevice(mesh_wifi)} set txpower fixed 0\n`);
        sf.write(`/usr/sbin/iw ${hardware.getPhyDevice(mesh_wifi)} set txpower fixed ${mesh_txpower}00\n`);
    }
    sf.close();
    if (filecopy("/tmp/local_services", "/etc/local/services")) {
        changes.localservices = true;
    }
    fs.unlink("/tmp/local_services");
    fs.chmod("/etc/local/services", 0o777);
}

//
// Make if official
//

// Handle special cases
const special = {
    dmz_mode: c.get("setup", "globals", "dmz_mode"),
    supernode_enable: c.get("aredn", "@supernode[0]", "enable"),
    watchdog_enable: c.get("aredn", "@watchdog[0]", "enable"),
    watchdog_pings: c.get("aredn", "@watchdog[0]", "ping_addresses"),
    watchdog_daily: c.get("aredn", "@watchdog[0]", "daily"),
    web_access: c.get("aredn", "@wan[0]", "web_access"),
    ssh_access: c.get("aredn", "@wan[0]", "ssh_access"),
    telnet_access: c.get("aredn", "@wan[0]", "telnet_access"),
    lan_dhcp_route: c.get("aredn", "@wan[0]", "lan_dhcp_route"),
    mesh_to_local_wan: c.get("aredn", "@wan[0]", "mesh_to_local_wan"),
    lan_to_remote_wan: c.get("aredn", "@wan[0]", "lan_to_remote_wan"),
    wifi_mode_0: c.get("wireless", "@wifi-iface[0]", "mode"),
    wifi_mode_1: c.get("wireless", "@wifi-iface[1]", "mode"),
    wifi_channel_0: c.get("wireless", "@wifi-device[0]", "channel"),
    wifi_channel_1: c.get("wireless", "@wifi-device[1]", "channel"),
    wifi_macfilter_0: c.get("wireless", "@wifi-device[0]", "macfilter"),
    wifi_macfilter_1: c.get("wireless", "@wifi-device[1]", "macfilter"),
    power_eth: c.get("aredn", "@poe[0]", "passthrough"),
    power_usb: c.get("aredn", "@usb[0]", "passthrough"),
    ntp_period: c.get("aredn", "@ntp[0]", "period"),
    beacon_enable: c.get("aredn", "@beacon[0]", "enable"),
    protocol_buffer_size: c.get("aredn", "@babel[0]", "protocol_buffer_size")

};
const nfiles = {};
let d = fs.opendir("/tmp/new_config");
if (d) {
    for (let file = d.read(); file; file = d.read()) {
        if (file != "." && file != "..") {
            nfiles[file] = true;
        }
    }
    d.close();
}
// Remove files we no longer need
d = fs.opendir("/tmp/config");
if (d) {
    for (let file = d.read(); file; file = d.read()) {
        if (file != "." && file != "..") {
            if (!nfiles(file)) {
                fs.unlink(`/etc/config/${file}`);
                if (file !== "/etc/config/ubootenv") {
                    changes.reboot = true;
                }
            }
        }
    }
    d.close();
}

for (let file in nfiles) {
    const ffile = `/tmp/new_config/${file}`;
    if (filecopy(ffile, `/etc/config/${file}`)) {
        switch (file) {
            case "system":
                changes.log = true;
                changes.system = true;
                changes.ntp = true;
                break;
            case "aredn":
            {
                const oc = uci.cursor();
                if (special.dmz_mode != oc.get("setup", "globals", "dmz_mode")) {
                    changes.reboot = true;
                }
                if (special.supernode_enable != oc.get("aredn", "@supernode[0]", "enable")) {
                    changes.reboot = true;
                }
                if (special.watchdog_enable != oc.get("aredn", "@watchdog[0]", "enable") ||
                    special.watchdog_pings != oc.get("aredn", "@watchdog[0]", "ping_addresses") ||
                    special.watchdog_daily != oc.get("aredn", "@watchdog[0]", "daily")) {
                    changes.manager = true;
                }
                if (special.beacon_enable != oc.get("aredn", "@beacon[0]", "enable")) {
                    changes.manager = true;
                }
                if (special.web_access != oc.get("aredn", "@wan[0]", "web_access")) {
                    changes.firewall = true;
                }
                if (special.ssh_access != oc.get("aredn", "@wan[0]", "ssh_access")) {
                    changes.firewall = true;
                }
                if (special.power_eth != oc.get("aredn", "@poe[0]", "passthrough")) {
                    changes.poe = true;
                }
                if (special.power_usb != oc.get("aredn", "@usb[0]", "passthrough")) {
                    changes.pou = true;
                }
                if (special.ntp_period != oc.get("setup", "@ntp[0]", "period")) {
                    changes.ntp = true;
                    const period = oc.get("aredn", "@ntp[0]", "period");
                    if (period == "continually") {
                        system("/etc/init.d/sysntp enable > /dev/null 2>&1");
                    }
                    else {
                        system("/etc/init.d/sysntp disable > /dev/null 2>&1");
                    }
                    if (period == "daily") {
                        if (fs.access("/etc/cron.hourly/update-clock")) {
                            fs.rename("/etc/cron.hourly/update-clock", "/etc/cron.daily/update-clock");
                        }
                    }
                    else {
                        if (fs.access("/etc/cron.daily/update-clock")) {
                            fs.rename("/etc/cron.daily/update-clock", "/etc/cron.hourly/update-clock");
                        }
                    }
                }
                if (special.lan_dhcp_route != oc.get("aredn", "@wan[0]", "lan_dhcp_route")) {
                    changes.network = true;
                    changes.babel = true;
                    changes.firewall = true;
                }
                if (special.mesh_to_local_wan != oc.get("aredn", "@wan[0]", "mesh_to_local_wan")) {
                    changes.network = true;
                    changes.babel = true;
                }
                if (special.lan_to_remote_wan != oc.get("aredn", "@wan[0]", "lan_to_remote_wan")) {
                    changes.network = true;
                    changes.babel = true;
                }
                if (special.protocol_buffer_size != oc.get("aredn", "@babel[0]", "protocol_buffer_size")) {
                    changes.babel = true;
                }
                break;
            }
            case "network":
                changes.network = true;
                changes.lqm = true; // and lqm because device assignment could change
                break;
            case "dhcp":
                changes.dnsmasq = true;
                break;
            case "dropbear":
                changes.dropbear = true;
                break;
            case "babel":
                changes.babel = true;
                break;
            case "firewall":
                changes.firewall = true;
                break;
            case "wireless":
            {
                const oc = uci.cursor();
                if (special.wifi_channel_0 != oc.get("wireless", "@wifi-device[0]", "channel") || special.wifi_channel_1 != oc.get("wireless", "@wifi-device[1]", "channel")) {
                    changes.manager = true;
                }
                if (special.wifi_mode_0 != oc.get("wireless", "@wifi-iface[0]", "mode") ||
                    special.wifi_mode_1 != oc.get("wireless", "@wifi-iface[1]", "mode") ||
                    special.wifi_macfilter_0 != oc.get("wireless", "@wifi-iface[0]", "macfilter") ||
                    special.wifi_macfilter_1 != oc.get("wireless", "@wifi-iface[1]", "macfilter")) {
                        // Only start the hostapd (etc) if we need to. This doesn't change what is currently running
                        // only what automatically runs in the future
                        if (oc.get("wireless", "@wifi-iface[0]", "mode") == "ap" ||
                            oc.get("wireless", "@wifi-iface[1]", "mode") == "ap" ||
                            oc.get("wireless", "@wifi-iface[0]", "mode") == "sta" ||
                            oc.get("wireless", "@wifi-iface[1]", "mode") == "sta") {
                                system("/etc/init.d/wpad enable > /dev/null 2>&1");
                        }
                        else {
                                system("/etc/init.d/wpad disable > /dev/null 2>&1");
                        }
                        changes.reboot = true;
                }
                else {
                    changes.wireless = true;
                }
            }
            default:
                changes.reboot = true;
                break;
        }
    }
    fs.unlink(ffile);
}
fs.rmdir("/tmp/new_config");

nvram.set("hsmmmesh", "settings", "node", node);
nvram.set("hsmmmesh", "settings", "tactical", tactical);

// Set file flags for whichever parts of the system require a restart/reboot
for (let k in changes) {
    if (changes[k]) {
        fs.mkdir("/tmp/reboot-required");
        fs.writefile(`/tmp/reboot-required/${k}`, `${changes[k]}`);
    }
}

exit(0);
