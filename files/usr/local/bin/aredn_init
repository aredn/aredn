#!/usr/bin/ucode
/*
 * Part of AREDN速 -- Used for creating Amateur Radio Emergency Data Networks
 * Copyright (C) 2021-2025 Tim Wilkinson
 * See Contributors file for additional contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Additional Terms:
 *
 * Additional use restrictions exist on the AREDN速 trademark and logo.
 * See AREDNLicense.txt for more info.
 *
 * Attributions to the AREDN速 Project must be retained in the source code.
 * If importing this code into a new or existing project attribution
 * to the AREDN速 project must be added to the source code.
 *
 * You must not misrepresent the origin of the material contained within.
 *
 * Modified versions must be modified to attribute to the original source
 * and be marked in reasonable ways as differentiate it from the original
 * version
 */

import * as fs from "fs";
import * as uci from "uci";
import * as hardware from "aredn.hardware";

const nvram = uci.cursor("/etc/local/uci");

let name = nvram.get("hsmmmesh", "settings", "node") ?? "";
let mac2 = nvram.get("hsmmmesh", "settings", "mac2") ?? "";
let dtdmac = nvram.get("hsmmmesh", "settings", "dtdmac") ?? "";
let wifi_mac = nvram.get("hsmmmesh", "settings", "wifimac") ?? "";

const defaults = {
    wifi_ip: "10.<MAC2>",
    wifi_mask: "255.255.255.255",
    lan_proto: "static",
    lan_ip: "172.27.0.1",
    lan_mask: "255.255.255.0",
    lan_dhcp: "1",
    dhcp_start: "5",
    dhcp_end: "25",
    wan_proto: "dhcp",
    wan_dns1: "8.8.8.8",
    wan_dns2: "8.8.4.4",
    wan_ip: "192.168.0.2",
    wan_mask: "255.255.255.0",
    wan_gw: "192.168.0.1",
    dtdlink_ip: "10.<DTDMAC>",
    time_zone: "UTC",
    time_zone_name: "UTC",
    ntp_server: "us.pool.ntp.org",
    ntp_server2: "time.cloudflare.com",
    ntp_active_server: "0",
    compat_version: "1.0"
};

const cfg = {};

function capture(cmd)
{
    const p = fs.popen(cmd);
    if (p) {
        const v = p.read("all");
        p.close();
        return trim(v);
    }
    return null;
}

//
// Setup the nvram
//

if (wifi_mac == "" || mac2 == "") {
    let hardware_mac = null;
    // If we have a radio ...
    if (fs.access("/sys/kernel/debug/ieee80211/phy0")) {
        let phy = null;
        const wlans = { phy0: true, phy1: true, wlan0: true, wlan1: true };
        for (let i = 0; i < 5; i++) {
            for (let wlan in wlans) {
                const f = fs.popen(`iwinfo ${wlan} info`);
                if (f) {
                    for (let line = f.read("line"); length(line); line = f.read("line")) {
                        const m = match(line, /PHY name:[ \t]*([a-z0-4]+)/);
                        if (m) {
                            phy = m[1];
                            break;
                        }
                    }
                    f.close();
                }
                if (phy) {
                    break;
                }
            }
            if (phy) {
                const f = fs.open(`/sys/class/ieee80211/${phy}/macaddress`);
                if (f) {
                    for (let line = f.read("line"); length(line); line = f.read("line")) {
                        const m = match(line, /(..:..:..:..:..:..)/);
                        if (m) {
                            hardware_mac = m[1];
                            break;
                        }
                    }
                    f.close();
                }
            }
            if (hardware_mac) {
                break;
            }
            sleep(5000);
        }
    }

    if (!hardware_mac) {
        // Fallback, create a random mac address instead
        hardware_mac = match(capture(`hexdump -n5 -e'/5 "02" 5/1 ":%02X"' /dev/urandom`), /^([^ \t]+)/)[1];
    }

    if (wifi_mac == "") {
        nvram.set("hsmmmesh", "settings", "wifimac", hardware_mac);
    }

    if (mac2 == "") {
        const m = match(hardware_mac, /..:..:..:(..):(..):(..)/);
        mac2 = `${hex(m[1])}.${hex(m[2])}.${hex(m[3])}`;
        nvram.set("hsmmmesh", "settings", "mac2", mac2);
    }
}

if (dtdmac == "") {
    let m = null;
    for (let i = 0; i < 5; i++) {
        m = match(hardware.getInterfaceMAC("br-lan"), /..:..:..:(..):(..):(..)/);
        if (m) {
            break;
        }
    }
    if (m) {
        dtdmac = `${hex(m[1])}.${hex(m[2])}.${hex(m[3])}`;
    }
    else {
        dtdmac = mac2;
    }
    if (dtdmac == mac2) {
        const m = match(dtdmac, /^(\d+)\.(\d+)\.(\d+)$/);
        let a = int(m[1]) + 1;
        if (a > 255) {
            a = 0;
        }
        dtdmac = `${a}.${m[2]}.${m[3]}`;
    }
    nvram.set("hsmmmesh", "settings", "dtdmac", dtdmac);
}

if (name == "") {
    name = "NOCALL";
    nvram.set("hsmmmesh", "settings", "node", name);
}

nvram.commit("hsmmmesh");

//
// Configure and repair _setup
//

// Load the defaults
for (let k in defaults) {
    cfg[k] = replace(replace(replace(defaults[k], "<NODE>", name), "<MAC2>", mac2), "<DTDMAC>", dtdmac);
}

// Override with the current config
const all = uci.cursor("/etc/config.mesh").get_all("setup", "globals") || {};
for (let k in all) {
    if (!match(k, /^\./)) {
        cfg[k] = all[k];
    }
}

// Make sure compat version is correct
const boardsystem = hardware.getBoard().system;
if (boardsystem && boardsystem.compat_version) {
    cfg.compat_version = boardsystem.compat_version;
}

// Radio
if (hardware.getRadioCount() > 0 && !cfg.radio0_mode) {
    const defaultwifi = hardware.getDefaultChannel("wlan0");
    cfg.radio0_mode = "mesh";
    cfg.radio0_ssid = cfg.radio0_ssid || "AREDN";
    cfg.radio0_channel = cfg.radio0_channel || defaultwifi.channel;
    cfg.radio0_bandwidth = cfg.radio0_bandwidth || defaultwifi.bandwidth;
    cfg.radio0_txpower = cfg.radio0_txpower || 19;
    cfg.radio0_distance = cfg.radio0_distance || 0;
}

// DHCP
if (!cfg.dmz_mode) {
    const amac2 = iptoarr(`10.${mac2}`);
    const dmac2 = (((amac2[0] << 24) + (amac2[1] << 16) + (amac2[2] << 8) + amac2[3]) * 8) % 0x1000000;
    const a = [ (dmac2 >> 24) & 255, (dmac2 >> 16) & 255, (dmac2 >> 8) & 255, dmac2 & 255 ];
    cfg.dmz_mode = 3;
    cfg.dmz_lan_ip = `10.${a[1]}.${a[2]}.${a[3] + 1}`;
    cfg.dmz_dhcp_start = 2;
    cfg.dmz_dhcp_end = 6;
    cfg.dmz_lan_mask = "255.255.255.248";
}

// And save
const c = uci.cursor("/etc/config.mesh");

fs.open("/etc/config.mesh/setup", "a").close();
if (!c.get("setup", "globals")) {
    c.set("setup", "globals", "globals");
}

for (let k in cfg) {
    c.set("setup", "globals", k, cfg[k]);
}
c.commit("setup");

// If this was an upgrade, make sure to remove the carried configuration so we dont apply it again
fs.unlink("/sysupgrade.tgz");

// If the node has been configured by the user we can complete the setup
if (nvram.get("hsmmmesh", "settings", "configured") != "0") {
    system("/usr/local/bin/node-setup");
    // Reboot when necessary
    if (fs.access("/tmp/reboot-required")) {
        if (fs.access("/etc/local/aredn_init_rebooted")) {
            print("Rebooting node requested, but would loop so ignoring\n");
            fs.unlink("/etc/local/aredn_init_rebooted");
        }
        else {
            print("Rebooting node\n");
            system("/sbin/mount_root done");
            fs.writefile("/etc/local/aredn_init_rebooted", "");
            system("/bin/sync");
            system("/sbin/reboot");
        }
    }
    else {
        fs.unlink("/etc/local/aredn_init_rebooted");
    }
}
