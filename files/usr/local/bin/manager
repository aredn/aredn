#!/usr/bin/ucode
/*
 * Part of AREDN速 -- Used for creating Amateur Radio Emergency Data Networks
 * Copyright (C) 2025 Tim Wilkinson
 * See Contributors file for additional contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Additional Terms:
 *
 * Additional use restrictions exist on the AREDN速 trademark and logo.
 * See AREDNLicense.txt for more info.
 *
 * Attributions to the AREDN速 Project must be retained in the source code.
 * If importing this code into a new or existing project attribution
 * to the AREDN速 project must be added to the source code.
 *
 * You must not misrepresent the origin of the material contained within.
 *
 * Modified versions must be modified to attribute to the original source
 * and be marked in reasonable ways as differentiate it from the original
 * version
 */

import * as fs from "fs";
import * as uloop from "uloop";
import * as log from "log";
import * as uci from "uci";
import * as socket from "socket";
import * as math from "math";
import * as ubus from "ubus";
import * as nl80211 from "nl80211";
import * as rtnl from "rtnl";
import * as configuration from "aredn.configuration";
import * as hardware from "aredn.hardware";
import * as babel from "aredn.babel";
import * as radios from "aredn.radios";
import * as network from "aredn.network";

const root = "/usr/local/bin/mgr/";

const tasks = [];
const dir = fs.opendir(root);
for (;;) {
    const entry = dir.read();
    if (!entry) {
        break;
    }
    if (match(entry, /\.uc$/)) {
        push(tasks, { name: entry, path: `${root}${entry}`, state: "I", ctx: null });
    }
}
dir.close();

uloop.init();
for (let i = 0; i < length(tasks); i++) {
    function fn(task) {
        return function() {
            log.openlog(`manager.${task.name}`, log.LOG_PID, log.LOG_DAEMON);
            switch (task.state) {
                case "I":
                case "I2":
                    log.syslog(log.LOG_NOTICE, task.state == "I" ? "Starting task" : "Restarting task");
                    task.state = "R";
                    task.ctx = {
                        log: log,
                        fs: fs,
                        uci: uci,
                        socket: socket,
                        math: math,
                        ubus: ubus,
                        nl80211: nl80211,
                        rtnl: rtnl,
                        configuration: configuration,
                        hardware: hardware,
                        babel: babel,
                        radios: radios,
                        network: network,
                        waitForTicks: function(ticks, next) {
                            task.task.set(ticks * 1000);
                            if (next) {
                                task.run = next;
                            }
                            return task.run;
                        },
                        exitApp: function() {
                            log.syslog(log.LOG_NOTICE, `Terminating task`);
                            task.task.cancel();
                            task.state = "E";
                            task.ctx = null;
                            task.run = null;
                            return task.run;
                        }
                    };
                    try {
                        const fn = loadfile(task.path, { raw_mode: true });
                        task.task.set(1);
                        task.run = call(fn, task.ctx, task.ctx);
                        if (!task.run && task.ctx) {
                            task.ctx.exitApp();
                        }
                    }
                    catch (e) {
                        log.syslog(log.LOG_ERR, `Startup exception: ${e} -- ${e.stacktrace}`);
                        task.state = "I2";
                        task.ctx = null;
                        task.run = null;
                        task.task.set(120000); // 2 minutes
                    }
                    break;
                case "R":
                    try {
                        task.task.set(1);
                        task.run = call(task.run, task.ctx, task.ctx) || task.run;
                    }
                    catch (e) {
                        log.syslog(log.LOG_ERR, `Exception: ${e} -- ${e.stacktrace}`);
                        task.state = "I2";
                        task.ctx = null;
                        task.run = null;
                        task.task.set(120000); // 2 minutes
                    }
                    break;
                case "E":
                default:
                    log.syslog(log.LOG_ERR, `Unexpected`);
                    task.task.cancel();
                    break;
            }
            log.closelog();
            gc("collect");
        };
    };
    tasks[i].task = uloop.timer(0, fn(tasks[i]));
}
gc("collect");
uloop.run();
